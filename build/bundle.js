/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/prototype.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/javascript-state-machine/lib/history.js":
/*!**************************************************************!*\
  !*** ./node_modules/javascript-state-machine/lib/history.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//-------------------------------------------------------------------------------------------------\n\nfunction camelize(label) {\n\n  if (label.length === 0)\n    return label;\n\n  var n, result, word, words = label.split(/[_-]/);\n\n  // single word with first character already lowercase, return untouched\n  if ((words.length === 1) && (words[0][0].toLowerCase() === words[0][0]))\n    return label;\n\n  result = words[0].toLowerCase();\n  for(n = 1 ; n < words.length ; n++) {\n    result = result + words[n].charAt(0).toUpperCase() + words[n].substring(1).toLowerCase();\n  }\n\n  return result;\n}\n\n//-------------------------------------------------------------------------------------------------\n\ncamelize.prepended = function(prepend, label) {\n  label = camelize(label);\n  return prepend + label[0].toUpperCase() + label.substring(1);\n}\n\n//-------------------------------------------------------------------------------------------------\n\nmodule.exports = camelize;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//-------------------------------------------------------------------------------------------------\n\nvar camelize = __webpack_require__(0);\n\n//-------------------------------------------------------------------------------------------------\n\nmodule.exports = function(options) { options = options || {};\n\n  var past       = camelize(options.name || options.past   || 'history'),\n      future     = camelize(                options.future || 'future'),\n      clear      = camelize.prepended('clear', past),\n      back       = camelize.prepended(past,   'back'),\n      forward    = camelize.prepended(past,   'forward'),\n      canBack    = camelize.prepended('can',   back),\n      canForward = camelize.prepended('can',   forward),\n      max        = options.max;\n\n  var plugin = {\n\n    configure: function(config) {\n      config.addTransitionLifecycleNames(back);\n      config.addTransitionLifecycleNames(forward);\n    },\n\n    init: function(instance) {\n      instance[past]   = [];\n      instance[future] = [];\n    },\n\n    lifecycle: function(instance, lifecycle) {\n      if (lifecycle.event === 'onEnterState') {\n        instance[past].push(lifecycle.to);\n        if (max && instance[past].length > max)\n          instance[past].shift();\n        if (lifecycle.transition !== back && lifecycle.transition !== forward)\n          instance[future].length = 0;\n      }\n    },\n\n    methods:    {},\n    properties: {}\n\n  }\n\n  plugin.methods[clear] = function() {\n    this[past].length = 0\n    this[future].length = 0\n  }\n\n  plugin.properties[canBack] = {\n    get: function() {\n      return this[past].length > 1\n    }\n  }\n\n  plugin.properties[canForward] = {\n    get: function() {\n      return this[future].length > 0\n    }\n  }\n\n  plugin.methods[back] = function() {\n    if (!this[canBack])\n      throw Error('no history');\n    var from = this[past].pop(),\n        to   = this[past].pop();\n    this[future].push(from);\n    this._fsm.transit(back, from, to, []);\n  }\n\n  plugin.methods[forward] = function() {\n    if (!this[canForward])\n      throw Error('no history');\n    var from = this.state,\n        to = this[future].pop();\n    this._fsm.transit(forward, from, to, []);\n  }\n\n  return plugin;\n\n}\n\n\n/***/ })\n/******/ ]);\n});\n\n//# sourceURL=webpack:///./node_modules/javascript-state-machine/lib/history.js?");

/***/ }),

/***/ "./node_modules/javascript-state-machine/lib/state-machine.js":
/*!********************************************************************!*\
  !*** ./node_modules/javascript-state-machine/lib/state-machine.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(target, sources) {\n  var n, source, key;\n  for(n = 1 ; n < arguments.length ; n++) {\n    source = arguments[n];\n    for(key in source) {\n      if (source.hasOwnProperty(key))\n        target[key] = source[key];\n    }\n  }\n  return target;\n}\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//-------------------------------------------------------------------------------------------------\n\nvar mixin = __webpack_require__(0);\n\n//-------------------------------------------------------------------------------------------------\n\nmodule.exports = {\n\n  build: function(target, config) {\n    var n, max, plugin, plugins = config.plugins;\n    for(n = 0, max = plugins.length ; n < max ; n++) {\n      plugin = plugins[n];\n      if (plugin.methods)\n        mixin(target, plugin.methods);\n      if (plugin.properties)\n        Object.defineProperties(target, plugin.properties);\n    }\n  },\n\n  hook: function(fsm, name, additional) {\n    var n, max, method, plugin,\n        plugins = fsm.config.plugins,\n        args    = [fsm.context];\n\n    if (additional)\n      args = args.concat(additional)\n\n    for(n = 0, max = plugins.length ; n < max ; n++) {\n      plugin = plugins[n]\n      method = plugins[n][name]\n      if (method)\n        method.apply(plugin, args);\n    }\n  }\n\n}\n\n//-------------------------------------------------------------------------------------------------\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//-------------------------------------------------------------------------------------------------\n\nfunction camelize(label) {\n\n  if (label.length === 0)\n    return label;\n\n  var n, result, word, words = label.split(/[_-]/);\n\n  // single word with first character already lowercase, return untouched\n  if ((words.length === 1) && (words[0][0].toLowerCase() === words[0][0]))\n    return label;\n\n  result = words[0].toLowerCase();\n  for(n = 1 ; n < words.length ; n++) {\n    result = result + words[n].charAt(0).toUpperCase() + words[n].substring(1).toLowerCase();\n  }\n\n  return result;\n}\n\n//-------------------------------------------------------------------------------------------------\n\ncamelize.prepended = function(prepend, label) {\n  label = camelize(label);\n  return prepend + label[0].toUpperCase() + label.substring(1);\n}\n\n//-------------------------------------------------------------------------------------------------\n\nmodule.exports = camelize;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//-------------------------------------------------------------------------------------------------\n\nvar mixin    = __webpack_require__(0),\n    camelize = __webpack_require__(2);\n\n//-------------------------------------------------------------------------------------------------\n\nfunction Config(options, StateMachine) {\n\n  options = options || {};\n\n  this.options     = options; // preserving original options can be useful (e.g visualize plugin)\n  this.defaults    = StateMachine.defaults;\n  this.states      = [];\n  this.transitions = [];\n  this.map         = {};\n  this.lifecycle   = this.configureLifecycle();\n  this.init        = this.configureInitTransition(options.init);\n  this.data        = this.configureData(options.data);\n  this.methods     = this.configureMethods(options.methods);\n\n  this.map[this.defaults.wildcard] = {};\n\n  this.configureTransitions(options.transitions || []);\n\n  this.plugins = this.configurePlugins(options.plugins, StateMachine.plugin);\n\n}\n\n//-------------------------------------------------------------------------------------------------\n\nmixin(Config.prototype, {\n\n  addState: function(name) {\n    if (!this.map[name]) {\n      this.states.push(name);\n      this.addStateLifecycleNames(name);\n      this.map[name] = {};\n    }\n  },\n\n  addStateLifecycleNames: function(name) {\n    this.lifecycle.onEnter[name] = camelize.prepended('onEnter', name);\n    this.lifecycle.onLeave[name] = camelize.prepended('onLeave', name);\n    this.lifecycle.on[name]      = camelize.prepended('on',      name);\n  },\n\n  addTransition: function(name) {\n    if (this.transitions.indexOf(name) < 0) {\n      this.transitions.push(name);\n      this.addTransitionLifecycleNames(name);\n    }\n  },\n\n  addTransitionLifecycleNames: function(name) {\n    this.lifecycle.onBefore[name] = camelize.prepended('onBefore', name);\n    this.lifecycle.onAfter[name]  = camelize.prepended('onAfter',  name);\n    this.lifecycle.on[name]       = camelize.prepended('on',       name);\n  },\n\n  mapTransition: function(transition) {\n    var name = transition.name,\n        from = transition.from,\n        to   = transition.to;\n    this.addState(from);\n    if (typeof to !== 'function')\n      this.addState(to);\n    this.addTransition(name);\n    this.map[from][name] = transition;\n    return transition;\n  },\n\n  configureLifecycle: function() {\n    return {\n      onBefore: { transition: 'onBeforeTransition' },\n      onAfter:  { transition: 'onAfterTransition'  },\n      onEnter:  { state:      'onEnterState'       },\n      onLeave:  { state:      'onLeaveState'       },\n      on:       { transition: 'onTransition'       }\n    };\n  },\n\n  configureInitTransition: function(init) {\n    if (typeof init === 'string') {\n      return this.mapTransition(mixin({}, this.defaults.init, { to: init, active: true }));\n    }\n    else if (typeof init === 'object') {\n      return this.mapTransition(mixin({}, this.defaults.init, init, { active: true }));\n    }\n    else {\n      this.addState(this.defaults.init.from);\n      return this.defaults.init;\n    }\n  },\n\n  configureData: function(data) {\n    if (typeof data === 'function')\n      return data;\n    else if (typeof data === 'object')\n      return function() { return data; }\n    else\n      return function() { return {};  }\n  },\n\n  configureMethods: function(methods) {\n    return methods || {};\n  },\n\n  configurePlugins: function(plugins, builtin) {\n    plugins = plugins || [];\n    var n, max, plugin;\n    for(n = 0, max = plugins.length ; n < max ; n++) {\n      plugin = plugins[n];\n      if (typeof plugin === 'function')\n        plugins[n] = plugin = plugin()\n      if (plugin.configure)\n        plugin.configure(this);\n    }\n    return plugins\n  },\n\n  configureTransitions: function(transitions) {\n    var i, n, transition, from, to, wildcard = this.defaults.wildcard;\n    for(n = 0 ; n < transitions.length ; n++) {\n      transition = transitions[n];\n      from  = Array.isArray(transition.from) ? transition.from : [transition.from || wildcard]\n      to    = transition.to || wildcard;\n      for(i = 0 ; i < from.length ; i++) {\n        this.mapTransition({ name: transition.name, from: from[i], to: to });\n      }\n    }\n  },\n\n  transitionFor: function(state, transition) {\n    var wildcard = this.defaults.wildcard;\n    return this.map[state][transition] ||\n           this.map[wildcard][transition];\n  },\n\n  transitionsFor: function(state) {\n    var wildcard = this.defaults.wildcard;\n    return Object.keys(this.map[state]).concat(Object.keys(this.map[wildcard]));\n  },\n\n  allStates: function() {\n    return this.states;\n  },\n\n  allTransitions: function() {\n    return this.transitions;\n  }\n\n});\n\n//-------------------------------------------------------------------------------------------------\n\nmodule.exports = Config;\n\n//-------------------------------------------------------------------------------------------------\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\nvar mixin      = __webpack_require__(0),\n    Exception  = __webpack_require__(6),\n    plugin     = __webpack_require__(1),\n    UNOBSERVED = [ null, [] ];\n\n//-------------------------------------------------------------------------------------------------\n\nfunction JSM(context, config) {\n  this.context   = context;\n  this.config    = config;\n  this.state     = config.init.from;\n  this.observers = [context];\n}\n\n//-------------------------------------------------------------------------------------------------\n\nmixin(JSM.prototype, {\n\n  init: function(args) {\n    mixin(this.context, this.config.data.apply(this.context, args));\n    plugin.hook(this, 'init');\n    if (this.config.init.active)\n      return this.fire(this.config.init.name, []);\n  },\n\n  is: function(state) {\n    return Array.isArray(state) ? (state.indexOf(this.state) >= 0) : (this.state === state);\n  },\n\n  isPending: function() {\n    return this.pending;\n  },\n\n  can: function(transition) {\n    return !this.isPending() && !!this.seek(transition);\n  },\n\n  cannot: function(transition) {\n    return !this.can(transition);\n  },\n\n  allStates: function() {\n    return this.config.allStates();\n  },\n\n  allTransitions: function() {\n    return this.config.allTransitions();\n  },\n\n  transitions: function() {\n    return this.config.transitionsFor(this.state);\n  },\n\n  seek: function(transition, args) {\n    var wildcard = this.config.defaults.wildcard,\n        entry    = this.config.transitionFor(this.state, transition),\n        to       = entry && entry.to;\n    if (typeof to === 'function')\n      return to.apply(this.context, args);\n    else if (to === wildcard)\n      return this.state\n    else\n      return to\n  },\n\n  fire: function(transition, args) {\n    return this.transit(transition, this.state, this.seek(transition, args), args);\n  },\n\n  transit: function(transition, from, to, args) {\n\n    var lifecycle = this.config.lifecycle,\n        changed   = this.config.options.observeUnchangedState || (from !== to);\n\n    if (!to)\n      return this.context.onInvalidTransition(transition, from, to);\n\n    if (this.isPending())\n      return this.context.onPendingTransition(transition, from, to);\n\n    this.config.addState(to);  // might need to add this state if it's unknown (e.g. conditional transition or goto)\n\n    this.beginTransit();\n\n    args.unshift({             // this context will be passed to each lifecycle event observer\n      transition: transition,\n      from:       from,\n      to:         to,\n      fsm:        this.context\n    });\n\n    return this.observeEvents([\n                this.observersForEvent(lifecycle.onBefore.transition),\n                this.observersForEvent(lifecycle.onBefore[transition]),\n      changed ? this.observersForEvent(lifecycle.onLeave.state) : UNOBSERVED,\n      changed ? this.observersForEvent(lifecycle.onLeave[from]) : UNOBSERVED,\n                this.observersForEvent(lifecycle.on.transition),\n      changed ? [ 'doTransit', [ this ] ]                       : UNOBSERVED,\n      changed ? this.observersForEvent(lifecycle.onEnter.state) : UNOBSERVED,\n      changed ? this.observersForEvent(lifecycle.onEnter[to])   : UNOBSERVED,\n      changed ? this.observersForEvent(lifecycle.on[to])        : UNOBSERVED,\n                this.observersForEvent(lifecycle.onAfter.transition),\n                this.observersForEvent(lifecycle.onAfter[transition]),\n                this.observersForEvent(lifecycle.on[transition])\n    ], args);\n  },\n\n  beginTransit: function()          { this.pending = true;                 },\n  endTransit:   function(result)    { this.pending = false; return result; },\n  failTransit:  function(result)    { this.pending = false; throw result;  },\n  doTransit:    function(lifecycle) { this.state = lifecycle.to;           },\n\n  observe: function(args) {\n    if (args.length === 2) {\n      var observer = {};\n      observer[args[0]] = args[1];\n      this.observers.push(observer);\n    }\n    else {\n      this.observers.push(args[0]);\n    }\n  },\n\n  observersForEvent: function(event) { // TODO: this could be cached\n    var n = 0, max = this.observers.length, observer, result = [];\n    for( ; n < max ; n++) {\n      observer = this.observers[n];\n      if (observer[event])\n        result.push(observer);\n    }\n    return [ event, result, true ]\n  },\n\n  observeEvents: function(events, args, previousEvent, previousResult) {\n    if (events.length === 0) {\n      return this.endTransit(previousResult === undefined ? true : previousResult);\n    }\n\n    var event     = events[0][0],\n        observers = events[0][1],\n        pluggable = events[0][2];\n\n    args[0].event = event;\n    if (event && pluggable && event !== previousEvent)\n      plugin.hook(this, 'lifecycle', args);\n\n    if (observers.length === 0) {\n      events.shift();\n      return this.observeEvents(events, args, event, previousResult);\n    }\n    else {\n      var observer = observers.shift(),\n          result = observer[event].apply(observer, args);\n      if (result && typeof result.then === 'function') {\n        return result.then(this.observeEvents.bind(this, events, args, event))\n                     .catch(this.failTransit.bind(this))\n      }\n      else if (result === false) {\n        return this.endTransit(false);\n      }\n      else {\n        return this.observeEvents(events, args, event, result);\n      }\n    }\n  },\n\n  onInvalidTransition: function(transition, from, to) {\n    throw new Exception(\"transition is invalid in current state\", transition, from, to, this.state);\n  },\n\n  onPendingTransition: function(transition, from, to) {\n    throw new Exception(\"transition is invalid while previous transition is still in progress\", transition, from, to, this.state);\n  }\n\n});\n\n//-------------------------------------------------------------------------------------------------\n\nmodule.exports = JSM;\n\n//-------------------------------------------------------------------------------------------------\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//-----------------------------------------------------------------------------------------------\n\nvar mixin    = __webpack_require__(0),\n    camelize = __webpack_require__(2),\n    plugin   = __webpack_require__(1),\n    Config   = __webpack_require__(3),\n    JSM      = __webpack_require__(4);\n\n//-----------------------------------------------------------------------------------------------\n\nvar PublicMethods = {\n  is:                  function(state)       { return this._fsm.is(state)                                     },\n  can:                 function(transition)  { return this._fsm.can(transition)                               },\n  cannot:              function(transition)  { return this._fsm.cannot(transition)                            },\n  observe:             function()            { return this._fsm.observe(arguments)                            },\n  transitions:         function()            { return this._fsm.transitions()                                 },\n  allTransitions:      function()            { return this._fsm.allTransitions()                              },\n  allStates:           function()            { return this._fsm.allStates()                                   },\n  onInvalidTransition: function(t, from, to) { return this._fsm.onInvalidTransition(t, from, to)              },\n  onPendingTransition: function(t, from, to) { return this._fsm.onPendingTransition(t, from, to)              },\n}\n\nvar PublicProperties = {\n  state: {\n    configurable: false,\n    enumerable:   true,\n    get: function() {\n      return this._fsm.state;\n    },\n    set: function(state) {\n      throw Error('use transitions to change state')\n    }\n  }\n}\n\n//-----------------------------------------------------------------------------------------------\n\nfunction StateMachine(options) {\n  return apply(this || {}, options);\n}\n\nfunction factory() {\n  var cstor, options;\n  if (typeof arguments[0] === 'function') {\n    cstor   = arguments[0];\n    options = arguments[1] || {};\n  }\n  else {\n    cstor   = function() { this._fsm.apply(this, arguments) };\n    options = arguments[0] || {};\n  }\n  var config = new Config(options, StateMachine);\n  build(cstor.prototype, config);\n  cstor.prototype._fsm.config = config; // convenience access to shared config without needing an instance\n  return cstor;\n}\n\n//-------------------------------------------------------------------------------------------------\n\nfunction apply(instance, options) {\n  var config = new Config(options, StateMachine);\n  build(instance, config);\n  instance._fsm();\n  return instance;\n}\n\nfunction build(target, config) {\n  if ((typeof target !== 'object') || Array.isArray(target))\n    throw Error('StateMachine can only be applied to objects');\n  plugin.build(target, config);\n  Object.defineProperties(target, PublicProperties);\n  mixin(target, PublicMethods);\n  mixin(target, config.methods);\n  config.allTransitions().forEach(function(transition) {\n    target[camelize(transition)] = function() {\n      return this._fsm.fire(transition, [].slice.call(arguments))\n    }\n  });\n  target._fsm = function() {\n    this._fsm = new JSM(this, config);\n    this._fsm.init(arguments);\n  }\n}\n\n//-----------------------------------------------------------------------------------------------\n\nStateMachine.version  = '3.0.1';\nStateMachine.factory  = factory;\nStateMachine.apply    = apply;\nStateMachine.defaults = {\n  wildcard: '*',\n  init: {\n    name: 'init',\n    from: 'none'\n  }\n}\n\n//===============================================================================================\n\nmodule.exports = StateMachine;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(message, transition, from, to, current) {\n  this.message    = message;\n  this.transition = transition;\n  this.from       = from;\n  this.to         = to;\n  this.current    = current;\n}\n\n\n/***/ })\n/******/ ]);\n});\n\n//# sourceURL=webpack:///./node_modules/javascript-state-machine/lib/state-machine.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/grammar.js":
/*!************************!*\
  !*** ./src/grammar.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * This file defines and generates the speech recognition grammar for improved\n * accuracy.\n */\n\n/**\n * ScratchGrammar namespace.\n */\nScratchGrammar = {}\n\n\nScratchGrammar.commands = `#JSGF V1.0;\n\t// Import the grammar that includes the name of the projects\n\timport <scratch_state_machine.project>\n\n\tgrammar scratch_state_machine.command;\n\n\tpublic <newProject> = new project|create new project|create project|make new project|make project;\n\n\tpublic <editExistingProject> = see inside ;\n\n\tpublic <editProject> = see inside;\n\n\tpublic <finishProject> = i'm done|i'm finished;\n\n\tpublic <play> = scratch <project>|scratch play <project>|play <project>|;\n\n\tpublic <playCurrentProject> = play project|start project|play current project|test project;\n\n\tpublic <return> = stop|i'm done|go back|quit|exit;\n\n\tpublic <getProjectNames> = what projects do i have|what have i made so far|what are my projects called;\n\n\tpublic <getProjectCount> = how many projects do i have|how many projects have i made;\n\tpublic <goToStep> = go to step |what's step |what is step ;\n\n\tpublic <nextStep> = go to next step|next step|what's next;\n\n\tpublic <previousStep> = previous step|go back a step;\n\n\tpublic <playStep> = play step|play current step|what does it do;\n\n\tpublic <insertStepBefore> = insert before step | before step ;\n\n\tpublic <insertStepAfter> = insert after step | after step ;\n\n\tpublic <deleteStep> = delete step ;\n\n\tpublic <replaceStep> = replace step <number> with ;\n\n\tpublic <replaceSound> = replace the <sound_name> sound with the <sound_name> sound;\n\n\tpublic <replaceInStep> = in step <number> replace  with ;\n\n\tpublic <stopEditing> = stop|i'm done|that's it;`\n\n// TODO: programmatically populate numbers?.\nScratchGrammar.numbers = `#JSGF V1.0;\ngrammar scratch_state_machine.numbers;\npublic <number> =  one | two | three | four | five | six | seven | eight |\nnine | ten | eleven | twelve | thirteen | fourteen | fifteen | sixteen |\nseventeen | eighteen | nineteen | twenty;\\n`\n\n// TODO: programmatically populate with more sounds.\nScratchGrammar.sounds = `#JSGF V1.0;\ngrammar scratch_state_machine.sounds;\npublic <sound_name> = meow|moo|boing|droplet';`\n\n/**\n * Get the grammar rules in JSFG V1.0 format.\n * @param {!Object} triggerMap - map of trigger types to regular expressions\n * @return {!String} the grammar rules\n */\nfunction getRules(triggerMap) {\n\tvar rules = []\n\tfor (var triggerType in triggerMap) {\n\t\tvar regexString = triggerMap[triggerType].toString().replace(/\\(\\.\\*\\)/g,\"\");\n\t\tvar matches = regexString.substring(1,regexString.length-1)\n\t\tvar rule = 'public <' + triggerType + '> = ' + matches + ';\\n'\n\t\trules.push(rule);\n\t}\n\treturn rules.join('\\n');\n}\n\n// Upon using the system, you want the grammar to recognize expected phrases more\n// easily.\nfunction generateGrammar(scratch) {\n\tvar header = `#JSGF V1.0;\n\tgrammar scratch_state_machine; \\n`\n\n\tvar stateMachineRules = getRules(scratch._triggers);\n\n\tvar dummyProject = new ScratchProject();\n\tvar projectRules = getRules(dummyProject.editTriggers);\n\tvar projectNameRule = 'public <project_name> = ' +\n\t\t\tObject.keys(scratch.projects).join('|') + ';\\n';\n\n\tvar grammar = header + stateMachineRules + projectRules + projectNameRule;\n\treturn grammar.replace(/\\\\/g,\"\")\n}\n\nfunction test_getRules() {\n\tvar triggers = {\n    'newProject': /new project|create new project|create project|make new project|make project/,\n    'editExistingProject': /see inside (.*)/,\n    'editProject': /see inside/,\n    'finishProject': /i'm done|i'm finished/,\n    'play': /scratch (.*)|scratch play (.*)|play (.*)|(.*)/,\n    'playCurrentProject': /play project|start project|play current project|test project/,\n    'return': /stop|i'm done|go back|quit|exit/,\n    'getProjectNames': /what projects do i have|what have i made so far|what are my projects called/,\n    'getProjectCount': /how many projects do i have|how many projects have i made/\n  }\n  console.log(getRules(triggers))\n}\n\nmodule.exports = ScratchGrammar;\n\n\n\n//# sourceURL=webpack:///./src/grammar.js?");

/***/ }),

/***/ "./src/prototype.js":
/*!**************************!*\
  !*** ./src/prototype.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * @fileoverview\n *\n * JavaScript for the Scratch Voice User Interface prototype.\n * @author Tina Quach (quacht@mit.edu)\n */\nglobal.ScratchStateMachine = __webpack_require__(/*! ./scratch_state_machine.js */ \"./src/scratch_state_machine.js\");\n\nglobal.scratch = new ScratchStateMachine();\n\nif (!window.localStorage.scratchProjects) {\n  window.localStorage.scratchProjects = JSON.stringify({});\n} else {\n  scratch.loadFromLocalStorage();\n}\n\nscratch._updatePlayRegex();\nscratch.updateGrammarWithProjects.bind(scratch);\nscratch.recognition.grammars.addFromString(ScratchGrammar.commands);\nscratch.recognition.grammars.addFromString(ScratchGrammar.numbers);\nscratch.recognition.grammars.addFromString(ScratchGrammar.sounds);\n\nscratch.observe('onAfterTransition', function() {\n  document.getElementById(\"current_state\").innerHTML = scratch.state;\n});\n\nglobal.final_transcript = '';\nglobal.recognizing = false;\nglobal.ignore_onend;\nglobal.start_timestamp;\n\nglobal.upgrade = function() {\n  start_button.style.visibility = 'hidden';\n  showInfo('info_upgrade');\n}\n\nglobal.two_line = /\\n\\n/g;\nglobal.one_line = /\\n/g;\nglobal.linebreak = function(s) {\n  return s.replace(two_line, '<p></p>').replace(one_line, '<br>');\n}\n\nglobal.first_char = /\\S/;\nglobal.capitalize = function(s) {\n  return s.replace(first_char, function(m) { return m.toUpperCase(); });\n}\n\ndocument.getElementById(\"start_button\").onclick =  function(event) {\n  if (recognizing) {\n    recognition.stop();\n    return;\n  }\n  final_transcript = '';\n  recognition.start();\n  ignore_onend = false;\n  final_span.innerHTML = '';\n  interim_span.innerHTML = '';\n  start_img.src = 'assets/mic-slash.gif';\n  showInfo('info_allow');\n  showButtons('none');\n  start_timestamp = event.timeStamp;\n}\n\nglobal.showInfo = function(s) {\n  if (s) {\n    for (global.child = info.firstChild; child; child = child.nextSibling) {\n      if (child.style) {\n        child.style.display = child.id == s ? 'inline' : 'none';\n      }\n    }\n    info.style.visibility = 'visible';\n  } else {\n    info.style.visibility = 'hidden';\n  }\n}\n\nglobal.current_style;\nglobal.showButtons = function(style) {\n  if (style == global.current_style) {\n    return;\n  }\n  global.current_style = style;\n}\n\n\nif (!('webkitSpeechRecognition' in window)) {\n  upgrade();\n} else {\n  start_button.style.display = 'inline-block';\n  global.recognition = scratch.recognition;\n  recognition.continuous = true;\n  recognition.interimResults = true;\n\n  recognition.onstart = function() {\n    recognizing = true;\n    showInfo('info_speak_now');\n    start_img.src = 'assets/mic-animate.gif';\n  };\n\n  recognition.onerror = function(event) {\n    if (event.error == 'no-speech') {\n      start_img.src = 'assets/mic.gif';\n      showInfo('info_no_speech');\n      ignore_onend = true;\n    }\n    if (event.error == 'audio-capture') {\n      start_img.src = 'assets/mic.gif';\n      showInfo('info_no_microphone');\n      ignore_onend = true;\n    }\n    if (event.error == 'not-allowed') {\n      if (event.timeStamp - start_timestamp < 100) {\n        showInfo('info_blocked');\n      } else {\n        showInfo('info_denied');\n      }\n      ignore_onend = true;\n    }\n  };\n\n  recognition.onend = function() {\n    recognizing = false;\n    if (ignore_onend) {\n      return;\n    }\n    start_img.src = 'assets/mic.gif';\n    if (!final_transcript) {\n      showInfo('info_start');\n      return;\n    }\n    showInfo('');\n    if (window.getSelection) {\n      window.getSelection().removeAllRanges();\n      global.range = document.createRange();\n      range.selectNode(document.getElementById('final_span'));\n      window.getSelection().addRange(range);\n    }\n\n  };\n\n  // Since recognition is continuous, we will get interim results based on the\n  // partial utterance.\n  // The API still helps us recognize when a pause has occured.\n  recognition.onresult = function(event) {\n    global.interim_transcript = '';\n    for (global.i = event.resultIndex; i < event.results.length; ++i) {\n      if (event.results[i].isFinal) {\n        final_transcript = event.results[i][0].transcript;\n        console.log(event.results[i][0].transcript)\n        // Analyze utterance.\n        scratch.handleUtterance(event.results[i][0].transcript)\n      } else {\n        interim_transcript += event.results[i][0].transcript;\n      }\n    }\n\n    final_transcript = capitalize(final_transcript);\n    final_span.innerHTML = linebreak(final_transcript);\n    interim_span.innerHTML = linebreak(interim_transcript);\n    if (final_transcript || interim_transcript) {\n      showButtons('inline-block');\n    }\n  };\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/prototype.js?");

/***/ }),

/***/ "./src/scratch_instruction.js":
/*!************************************!*\
  !*** ./src/scratch_instruction.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Define ScratchInstruction class for converting sentences\n * to Scratch programs\n * @author Tina Quach (quacht@mit.edu)\n */\n\n/**\n * ScratchInstruction class\n */\nclass ScratchInstruction {\n  /**\n   * Constructor for the ScratchInstruction\n   * @param {!String} rawInstruction - the utterance from the user.\n   * @param {!ScratchAction} action - the action to which this instruction\n   *    belongs.\n   */\n  constructor(rawInstruction) {\n    this.raw = rawInstruction.trim();\n    try {\n      this.steps = this.getSteps();\n    } catch(e) {\n      this.steps = null;\n    }\n  }\n\n  /**\n   * Get the sentences in the instruction that use undefined actions.\n   * @param {!String} instruction - String containing the instruction\n   * @return {!Array<!String>} an array of unsupported sentences.\n   */\n  static getUnsupportedSteps(instruction) {\n    // Detect multiple statements and split them.\n    let sentences = instruction.replace(/([.?!])\\s*(?=[A-Z])/g, \"$1|\").split(\"|\");\n    var unknownActions = [];\n    for (var i = 0; i < sentences.length; i++) {\n      try {\n        var instructionJson = ScratchInstruction.extractArgs(sentences[i]);\n        var scratchInstruction = ScratchInstruction.jsonToScratch(instructionJson);\n      } catch (e) {\n        unknownActions.push(sentences[i]);\n      }\n    }\n    return unknownActions;\n  }\n\n  /**\n   * Returns the steps of the Scratch program.\n   */\n  getSteps() {\n    // Detect multiple statements and split them.\n    let sentences = this.raw.replace(/([.?!])\\s*(?=[A-Z])/g, \"$1|\").split(\"|\");\n    var steps = [];\n    for (var i = 0; i < sentences.length; i++) {\n      try {\n        var instructionJson = ScratchInstruction.extractArgs(sentences[i]);\n        var scratchInstruction = ScratchInstruction.jsonToScratch(instructionJson);\n        steps.push(scratchInstruction);\n      } catch (e) {\n        console.log(e);\n        throw new Error(\"Failed to get steps from instruction: \" + this.raw);\n      }\n    }\n    return steps;\n  }\n\n  /**\n   * Helper function for getSteps. Returns a JSON representing the instruction.\n   * @param {!String} instruction A sentence that may contain a command.\n   * @return JSON object encoding information for generating Scratch program.\n   */\n  static extractArgs(sentence) {\n    sentence = sentence.trim();\n    var instructionJson = {\n      original: sentence\n    };\n\n    if (!sentence) {\n      return instructionJson;\n    }\n\n    let commandTemplates = {\n      'when EVENT, you CMD': /[wW]hen (.*),? you (.*)/,\n      'then/next/after, CMD': /([Tt]hen|[nN]ext|[aA]fter),? (.*)/,\n      'first, CMD': /[fF]irst,? (.*)/,\n    };\n    var keys = Object.keys(commandTemplates);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var matches = Utils.match(sentence, commandTemplates[key]);\n      if (matches) {\n        switch (key) {\n          case 'when EVENT, you CMD':\n            instructionJson.event = matches[1];\n            instructionJson.command = matches[2];\n            return instructionJson;\n          case 'then/next/after, CMD':\n            instructionJson.event = 'after last command';\n            instructionJson.command = matches[2];\n            return instructionJson;\n          case 'first, CMD':\n            instructionJson.event = 'first';\n            instructionJson.command = matches[1];\n            return instructionJson;\n        }\n      }\n    }\n\n    instructionJson.command = sentence;\n\n    return instructionJson;\n  }\n\n  /**\n   * Helper function for getSteps. Returns a JSON representing the instruction.\n   * @param {!String} instruction A sentence that may contain a command.\n   */\n  static jsonToScratch(instructionJson) {\n    if (!instructionJson.command) {\n      return null;\n    }\n\n    // Process command.\n    var instructionTokens = instructionJson.command.split(' ');\n    if (instructionTokens) {\n      // Assume first word is the verb and the rest of the command is an\n      // argument.\n      var verb = instructionTokens[0];\n\n      // Check for all built in commands, mapped to Scratch programs.\n      // TODO: add more cases to handle wider variety of possible scratch\n      // commands.\n      if (verb.toLowerCase() === 'say') {\n        var opcode = 'say:';\n      } else {\n        // Verb is not recognized\n        throw new Error(\"Scratch does not know how to '\" + verb + \"'\");\n      }\n      var command = [opcode, instructionTokens.slice(1).join(' ')];\n    }\n\n    if (instructionJson.event) {\n      if (instructionJson.event.toLowerCase().startsWith('i say')) {\n        let argument = instructionJson.event.substring(6);\n        command = [[\"doAsk\", \"\"],[\"doIf\", [\"=\", [\"answer\"], argument], [command]]];\n      }\n      // else if (instructionJson.event == 'first') {\n      //   // TODO: Need some way to pass this information to Scratch model for building the progam.\n      // } else if (instructionJson.event == 'after last command') {\n      //   // TODO: Need some way to pass this information to Scratch model for building the progam.\n      // }\n    }\n\n    return command;\n  }\n}\n\nmodule.exports = ScratchInstruction;\n\n//# sourceURL=webpack:///./src/scratch_instruction.js?");

/***/ }),

/***/ "./src/scratch_project.js":
/*!********************************!*\
  !*** ./src/scratch_project.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Defines the ScratchProject object as a JavaScript state\n * machine.\n *\n * @author quacht@mit.edu (Tina Quach)\n */\nvar StateMachine = __webpack_require__(/*! javascript-state-machine */ \"./node_modules/javascript-state-machine/lib/state-machine.js\");\nconst ScratchInstruction = __webpack_require__(/*! ./scratch_instruction.js */ \"./src/scratch_instruction.js\");\nconst Utils = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n\n\n// TODO: idea: move the edit commands to the state machine level instead of the\n// scratch project level, since we manage what the currentproject is.\n// to resolve the issue of this referring to the wrong this.\n\nvar ScratchProject = StateMachine.factory({\n  init: 'create',\n  transitions: [\n    // Support linear project creation process.\n    { name: 'startProjectCreation', from: 'create', to: 'empty'},\n    { name: 'nameProject', from: 'empty', to: 'named'},\n    { name: 'addInstruction', from: 'named', to: 'nonempty'},\n    { name: 'addInstruction', from: 'nonempty', to: 'nonempty'},\n    { name: 'finishProject', from: 'nonempty', to: 'nonempty'},\n    { name: 'finishProject', from: '*', to: (s) => { return s} },\n    { name: 'goto', from: '*', to: function(s) { return s } }\n  ],\n  data: function(scratchStateMachine) {\n    return {\n      scratch: scratchStateMachine,\n      name: null,\n      instructions: [],\n      // TODO: deal with 1 versus 0 based indexing.\n      // TODO: handle word forms of words in referencing steps.\n      instructionPointer: null,\n      editTriggers: {\n        goToStep: /go to step (.*)|what's step (.*)|what is step (.*)/,\n        nextStep: /go to next step|next step|what's next/,\n        previousStep: /previous step|go back a step/,\n        playStep: /play step|play current step|what does it do/,\n        insertStepBefore: /insert (.*) before step (.*)|(.*) before step (.*)/,\n        insertStepAfter: /insert (.*) after step (.*)|(.*) after step (.*)/,\n        deleteStep: /delete step (.*)/,\n        // TODO: distinguish between replacing everywhere and replacing in a\n        // specific place.\n        replaceStep: /replace step (.*) with (.*)/,\n        replaceSound: /replace the (.*) sound with the (.*) sound'/,\n        // TODO: address potential complex behavior in line below.\n        replaceInStep: /in step (.*) replace (.*) with (.*)/,\n        stopEditing: /stop|i\\'m done|that\\'s it'/\n      },\n      editCommands: {\n        _describeCurrentStep: () => {\n          // this does not refer to the state machine, but to the editCommands\n          // object holding these functions.\n          if (0 < this.instructionPointer &&\n              this.instructionPointer <= this.instructions.length) {\n            this.scratch.say('Step ' + this.instructionPointer);\n            this.scratch.say(this.instructions[this.instructionPointer-1].raw)\n            return true;\n          } else {\n            return false;\n          }\n        },\n        goToStep: (args) => {\n          this.instructionPointer = Utils.text2num(args[1]);\n          if (this.instructionPointer == null) {\n            this.instructionPointer = parseInt(args[1]);\n          }\n          if (!this.editCommands._describeCurrentStep()) {\n            this.scratch.say('there is no step ' + this.instructionPointer);\n          }\n        },\n        nextStep: () => {\n          this.instructionPointer++;\n          if (this.instructionPointer <= this.instructions.length) {\n            this.editCommands._describeCurrentStep();\n          } else {\n            this.instructionPointer--;\n            this.scratch.say('No more steps');\n          }\n        },\n        previousStep: () => {\n          this.instructionPointer--;\n          if (this.instructionPointer > 0) {\n            this.editCommands._describeCurrentStep();\n          } else {\n            this.instructionPointer++;\n            this.scratch.say('No more steps');\n          }\n        },\n\n        // todo - test below\n        playStep: function() {\n          var steps = this.instructions[this.instructionPointer-1].getSteps();\n          // Assuming that the project can only be made of 'say' instructions\n          for (var i = 0; i < steps.length; i++) {\n            scratch.say(steps[i][1]);\n          }\n        },\n        insertStepBefore: function(args) {\n          // TODO: use try catch to handle inability to convert the Scratch\n          // instruction.\n          var stepToInsert = new ScratchInstruction(args[1]);\n          var referenceStepNumber = Utils.text2num(args[2])-1;\n          if (referenceStepNumber == null) {\n            referenceStepNumber = parseInt(args[2])-1;\n          }\n          this.instructions.splice(referenceStepNumber, 0, stepToInsert);\n          this.instructionPointer = referenceStepNumber;\n          console.log(this.instructions);\n        },\n        insertStepAfter: function(args) {\n          var stepToInsert = new ScratchInstruction(args[1]);\n          var referenceStepNumber = Utils.text2num(args[2])-1;\n          if (referenceStepNumber == null) {\n            referenceStepNumber = parseInt(args[2])-1;\n          }\n          this.instructions.splice(referenceStepNumber + 1, 0, stepToInsert);\n          this.instructionPointer = referenceStepNumber + 1;\n          this.scratch.say('inserted step');\n          console.log(this.instructions);\n        },\n        deleteStep: function(args) {\n          console.log(this);\n          var index = Utils.text2num(args[1])-1;\n          if (index == null) {\n            index = parseInt(args[1])-1;\n          }\n          var removedScratchInstruction = this.instructions.splice(index, 1);\n          this.scratch.say('Removed step ' + (index+1));\n          console.log(this.instructions);\n        },\n        replaceStep: function(args) {\n          var index = Utils.text2num(args[1])-1;\n          if (index == null) {\n            index = parseInt(args[1])-1;\n          }\n          var step = new ScratchInstruction(args[2]);\n          if (!step) {\n            this.scratch.say(step + 'is not a Scratch command');\n          }\n          this.instructions.splice(index, 1, step);\n          this.scratch.say('replaced step ' + (index+1));\n          console.log(this.instructions);\n        },\n        replaceInStep: function(args) {\n          var index = Utils.text2num(args[1])-1;\n          if (index == null) {\n            index = parseInt(args[1])-1;\n          }\n          var oldWord = args[2];\n          var newWord = args[3];\n          var instructionToModify = this.instructions[index];\n          // TODO: determine how to replace things w/in a step.\n        },\n        replaceSound: function(args) {\n          var oldSound = args[1];\n          var newSound = args[2];\n          // TODO: how does sound work in Scratch Programs.\n        }\n      }\n    }\n  },\n  methods: {\n    onStartProjectCreation() {\n      return new Promise(function(resolve, reject) {\n        this.scratch.say('What do you want to call it?');\n        resolve();\n      });\n    },\n    onNameProject: function() {\n      return new Promise(function(resolve, reject) {\n        // problem w/ using this.name is that this refers to the window--NOT to the scratch project.\n        this.scratch.say('Okay. When you say, Scratch, ' + this.scratch.currentProject.name + ', Ill play the project. Whats the first step?');\n        resolve();\n      })\n    },\n    onAddInstruction: function(utterance) {\n      return new Promise(function(resolve, reject) {\n        this.scratch.say('Okay, whats the next step?');\n        resolve();\n      })\n    },\n    onFinishProject: function(utterance) {\n      return new Promise(function(resolve, reject) {\n        this.scratch.say('Cool, now you can say, Scratch, ' + this.scratch.currentProject.name + ', to play the project.');\n        resolve();\n      })\n    },\n    /**\n     * Return Scratch program.\n     * @return {Array<Array>} Scratch program generated from instructions\n     */\n    getScratchProgram: function() {\n      let steps = this.instructions.map(instruction => instruction.steps[0]);\n      // Everytime you want to execute the program, you add a\n      // when green flag block to start it.\n      return [['whenGreenFlag']].concat(steps);\n    },\n    _getName: function(utterance) {\n      var pattern = /call the project(.*)/;\n      var matches = Utils.match(utterance, pattern);\n      if (matches && matches.length > 0) {\n        return matches[1].trim();\n      } else {\n        return utterance.trim();\n      }\n    },\n    handleUtterance: function(utterance) {\n      utterance = Utils.removeFillerWords(utterance.toLowerCase()).trim();\n\n      // Name project\n      if (this.state == 'create') {\n        if (this.name) {\n          this.goto('named');\n        } else {\n          this.startProjectCreation();\n        }\n      }\n      if (this.state == 'empty') {\n        this.name = this._getName(utterance);\n        this.scratch.projects[this.name] = this.scratch.currentProject;\n        delete this.scratch.projects['Untitled-'+this.scratch.untitledCount];\n        this.nameProject();\n      // Add to or finish project.\n      } else if (this.state == 'named' || this.state == 'nonempty') {\n        // Detect project completion.\n        if (utterance.indexOf(\"that's it\") != -1) {\n          this.finishProject(this.state);\n          return 'exit';\n        }\n\n        // Detect and handle explicit edit commands.\n        if (this._handleEditCommands(utterance)) {\n          return;\n        }\n\n        // Parse instruction to add as a last result.\n        var instruction = new ScratchInstruction(utterance);\n        if (instruction.steps != null) {\n          this.instructions.push(instruction);\n          this.addInstruction();\n        } else {\n          this.scratch.say(\"I heard you say \" + utterance);\n          this.scratch.say(\"That doesn't match any Scratch commands.\");\n        }\n      }\n    },\n    handleUtteranceDuringExecution: function(utterance) {\n      var scratchProject = this;\n      if (utterance == 'scratch stop') {\n        this.synth.cancel();\n      } else if (utterance == 'scratch pause') {\n        this.synth.pause();\n      } else if (utterance == 'scratch resume' || utterance == 'scratch unpause') {\n        this.synth.resume();\n      } else {\n        // Utterance should be an argument for the project.\n        if (utterance == this.tempTrigger) {\n          this.scratch.say(this.tempResponse)\n          this.scratch.executeCurrentProject(scratch, 'WhereItLeftOff');\n        }\n      }\n    },\n    /**\n     * If the utterance matches the form of a supported program editing\n     * command, execute the command.\n     */\n    _handleEditCommands: function(utterance) {\n      utterance = Utils.removeFillerWords(utterance.toLowerCase());\n\n      var scratchProject = this;\n      for (var commandType in this.editTriggers) {\n        var args = Utils.match(utterance, this.editTriggers[commandType]);\n        if (args) {\n          this.editCommands[commandType].call(scratchProject,args);\n          this.scratch.saveToLocalStorage();\n          return true;\n        }\n      }\n    }\n  }\n});\n\nmodule.exports = ScratchProject;\n\n//# sourceURL=webpack:///./src/scratch_project.js?");

/***/ }),

/***/ "./src/scratch_state_machine.js":
/*!**************************************!*\
  !*** ./src/scratch_state_machine.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Defines a factory/constructor for the ScratchStateMachine\n *\n * @author quacht@mit.edu (Tina Quach)\n */\nconst StateMachine = __webpack_require__(/*! javascript-state-machine */ \"./node_modules/javascript-state-machine/lib/state-machine.js\");\nconst StateMachineHistory = __webpack_require__(/*! javascript-state-machine/lib/history */ \"./node_modules/javascript-state-machine/lib/history.js\")\nconst ScratchProject = __webpack_require__(/*! ./scratch_project.js */ \"./src/scratch_project.js\");\nconst Utils = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\nconst ScratchGrammar = __webpack_require__(/*! ./grammar.js */ \"./src/grammar.js\");\n\n\nvar ScratchStateMachine = new StateMachine.factory({\n  init: 'Home',\n  transitions: [\n    { name: 'renameCurrentProject', from: '*', to: function() { return this.state} },\n    { name: 'renameProject', from: '*', to: function() { return this.state} },\n    { name: 'deleteProject', from: '*', to: function() { return this.state} },\n    { name: 'editExistingProject', from: 'Home',  to: 'InsideProject' },\n    { name: 'newProject', from: 'Home',  to: 'InsideProject' },\n    // Return should take you back to the last state\n    { name: 'return',   from: '*', to: function() {\n        return this.history[this.history.length - 2];\n      }\n    }, {\n      name: 'finishProject', from: 'InsideProject', to: 'Home'},\n    { name: 'play', from: 'Home', to: 'PlayProject'},\n    { name: 'play', from: 'PlayProject', to: 'PlayProject'},\n    { name: 'newProject', from: 'PlayProject',  to: 'InsideProject' },\n    { name: 'playCurrentProject', from: 'InsideProject', to: 'PlayProject'},\n    { name: 'editProject', from: 'PlayProject', to: 'InsideProject' },\n    // Support this.goto(STATE_NAME);\n    { name: 'goto', from: '*', to: function(s) { return s } },\n    { name: 'stay', from: '*', to: function() { return this.state} },\n    { name: 'getCurrentProject', from: '*', to: function() { return this.state} },\n    { name: 'getProjectNames', from: '*', to: function() { return this.state} },\n    { name: 'getProjectCount', from: '*', to: function() { return this.state} },\n\n  ],\n  data: function() {\n    return {\n      projects: {},\n      untitledCount: 0,\n      // Project currently being edited\n      projectToPlay: null,\n      currentProject: null,\n      synth: window.speechSynthesis,\n      recognition: new webkitSpeechRecognition(),\n      // Triggers should be listed from more specific to more general to\n      // ensure that the best fit trigger gets matched to the utterance.\n      _triggers: {\n        'newProject': /new project|create a? new project|create a? project|make a? new project|make a? project/,\n        'deleteProject': /delete (.*) project/,\n        'renameCurrentProject': /rename current project to (.*)/,\n        'renameProject': /change name of (.*) project to (.*)/,\n        'editExistingProject': /see inside (.*)|what's inside (.*)/,\n        'editProject': /see inside|what's inside/,\n        'finishProject': /i'm done|i'm finished/,\n        'play': /scratch (.*)|scratch play (.*)|play (.*)/,\n        'playCurrentProject': /play (?:the)? ?project|start (?:the)? ?project|play c(?:the)? ?urrent project|test (?:the)? ?project/,\n        'return': /stop|i'm done|go back|quit|exit/,\n        'getCurrentProject': /get (?:the)? ?current project|what project am i on|whats my current project|what is my current project/,\n        'getProjectNames': /what projects do i have|what have i made so far|what are my projects called/,\n        'getProjectCount': /how many projects do i have|how many projects have i made/\n      }\n    }\n  },\n  plugins: [\n    new StateMachineHistory()     //  <-- plugin enabled here\n  ],\n  methods: {\n    renameProject: (scratch, oldName, newName) => {\n      scratch.projects[newName] = scratch.projects[oldName]\n      scratch.projects[newName].name = newName;\n      delete scratch.projects[oldName];\n      scratch.removeFromLocalStorage(oldName);\n      scratch.saveToLocalStorage();\n    },\n    onGetCurrentProject: (lifecycle, scratch) => {\n      if (scratch.currentProject) {\n        scratch.say('The current project is ' + scratch.currentProject.name);\n      } else {\n        scratch.say('You are not currently on a project');\n      }\n    },\n    onRenameCurrentProject: (lifecycle, scratch, args) => {\n      if (scratch.currentProject) {\n        var newName = args[1];\n        scratch.renameProject(scratch, scratch.currentProject.name, newName);\n        scratch.say('The current project is now called ' + scratch.currentProject.name);\n      } else {\n        scratch.say('You are not currently on a project');\n        // TODO(quacht): support an interaction where instead of the above,\n        // scratch also says and responds to\n        // What project would you like to rename?\n      }\n    },\n    onRenameProject: (lifecycle, scratch, args) => {\n        var oldName = args[1];\n        var newName = args[2];\n\n        // play the project that matches!\n        for (var projectName in scratch.projects) {\n          if (scratch._removeFillerWords(projectName) == oldName) {\n            scratch.renameProject(scratch, projectName, newName)\n            scratch.say('Renamed ' + projectName + ' to ' + newName)\n            return;\n          }\n        }\n\n        scratch.say('The current project is ' + scratch.currentProject.name);\n        scratch.say('You are not currently on a project');\n        // TODO(quacht): support an interaction where instead of the above,\n        // scratch also says and responds to\n        // What project would you like to rename?\n    },\n    onDeleteProject: (lifecycle, scratch, args, utterance) => {\n      return new Promise(function(resolve, reject) {\n        var projectToPlayName = args[1].trim();\n\n        // play the project that matches!\n        for (var projectName in scratch.projects) {\n          if (Utils.removeFillerWords(projectName) == projectToPlayName) {\n            scratch.say(projectName + ' project deleted.')\n            delete scratch.projects[projectName];\n            scratch.removeFromLocalStorage(projectName);\n            resolve();\n            return;\n          }\n        }\n\n        // TODO: Does args[1] actually contain the project name as it is said?\n        // or will the filler words be removed.\n        scratch.say(\"You said \" + utterance);\n        scratch.say(\"I can't delete a project I don't have\");\n        resolve();\n        scratch.return();\n      })\n    },\n    onGetProjectNames: (lifecycle, scratch) => {\n      return new Promise(function(resolve, reject) {\n        var whatToSay = Object.keys(scratch.projects);\n        whatToSay.splice(whatToSay.length-1, 0, 'and');\n        whatToSay.join(',')\n        scratch.say(whatToSay);\n        resolve();\n      });\n    },\n    onGetProjectCount: (lifecycle, scratch) => {\n      return new Promise(function(resolve, reject) {\n        var count = Object.keys(scratch.projects).length;\n        scratch.say('You have ' + count + ' projects');\n        resolve();\n      });\n    },\n    onNewProject: (lifecycle, scratch) => {\n      return new Promise(function(resolve, reject) {\n        console.log(scratch);\n        scratch.currentProject = new ScratchProject(scratch);\n        scratch.untitledCount++;\n        scratch.projects['Untitled-' + scratch.untitledCount] = scratch.currentProject;\n        scratch.currentProject.startProjectCreation();\n        resolve();\n      });\n    },\n    onReturn: (lifecycle, scratch) => {\n      return new Promise(function(resolve, reject) {\n        scratch.say('Returning to previous state: ' + scratch.state);\n        resolve();\n      });\n    },\n    // Play existing project\n    onPlay: (lifecycle, scratch, args, utterance) => {\n      return new Promise(function(resolve, reject) {\n        var projectToPlayName = args[1].trim();\n\n        // play the project that matches!\n        for (var projectName in scratch.projects) {\n          if (Utils.removeFillerWords(projectName) == projectToPlayName) {\n            scratch.currentProject = scratch.projects[projectName];\n            scratch.say('playing project');\n            scratch.executeCurrentProject(scratch, 'FromStart');\n            // TODO(quacht): saying I'm done playing the project doesnt work\n            // here when doing event handling.\n            // scratch.say('done playing project');\n            resolve();\n            return;\n          }\n        }\n\n        // TODO: Does args[1] actually contain the project name as it is said?\n        // or will the filler words be removed.\n        scratch.say(\"You said \" + utterance);\n        scratch.say(\"I don't have a project called \" + args[1]);\n        resolve();\n        scratch.return();\n      })\n    },\n    onFinishProject: function() {\n      return new Promise(function(resolve, reject) {\n        scratch.saveToLocalStorage();\n        scratch._updatePlayRegex();\n        // TODO: cue exiting project\n        // Save project.\n        resolve();\n      });\n    },\n    onEditExistingProject: (lifecycle, scratch, args) => {\n      return new Promise(function(resolve, reject) {\n        console.log(args);\n        var projectName = args[1];\n        var stepCount = scratch.projects[projectName].instructions.length;\n        scratch.say('Opening project ' + projectName + ' for editing');\n        scratch.say('There are ' + stepCount + ' steps');\n        resolve();\n      });\n    },\n    onEditProject: (lifecycle, scratch) => {\n      return new Promise(function(resolve, reject) {\n        scratch.say('Opening project ' + scratch.currentProject.name + ' for editing');\n        // TODO: begin edit project flow.\n        resolve();\n      });\n    },\n    onPlayCurrentProject: (lifecycle, scratch) => {\n      return new Promise(function(resolve, reject) {\n        scratch.saveToLocalStorage();\n        scratch.say('Playing current project ' + scratch.currentProject.name);\n        scratch.executeCurrentProject(scratch, 'FromStart');\n        scratch.say('done playing project');\n        resolve();\n      });\n    },\n    /**\n     * Speak aloud given text.\n     * @param {!String} whatToSay - text to say aloud.\n     */\n    say: function(whatToSay) {\n      var whatToSay = new SpeechSynthesisUtterance(whatToSay);\n\n      // Stop speech recognition during speech synthesis.\n      var scratch = this;\n      whatToSay.onstart = function(event) {\n        scratch.recognition.stop();\n      }\n      whatToSay.onend = function(event) {\n        scratch.recognition.start();\n      }\n\n      // Synthesis speech!\n      this.synth.speak(whatToSay);\n      console.log('saying' + whatToSay.text);\n    },\n    /**\n     * Execute current project.\n     * @param {string} mode - 'FromStart' to execute the project from the first\n     *    or 'WhereItLeftOff'.\n     */\n    executeCurrentProject: (scratch, mode) => {\n      if (!scratch.currentProject) {\n        console.log(scratch);\n        throw Error('scratch.currentProject is ' + scratch.currentProject);\n      }\n      if (mode == 'WhereItLeftOff') {\n        var startIndex = scratch.currentProject.instructionPointer;\n      } else if ('FromStart') {\n        // Start at index 1 to skip the \"when green flag clicked instruction\"\n        var startIndex = 1;\n      }\n\n      var scratchProgram = scratch.currentProject.getScratchProgram();\n      for (var i = startIndex; i < scratchProgram.length; i++) {\n        var opcode = scratchProgram[i][0];\n        var args = scratchProgram[i][1];\n        if (opcode == 'say:') {\n            scratch.say(scratchProgram[i][1]);\n        } else if (Array.isArray(opcode)) {\n          if (opcode[0] == 'doAsk')\n            if (opcode[1] == '') {\n            // Handle 'when i say event'\n            var whatToListenFor = args[1][2];\n            var whatToSay = args[2][0][1];\n            scratch.currentProject.tempTrigger = whatToListenFor;\n            scratch.currentProject.tempResponse= whatToSay;\n            scratch.currentProject.instructionPointer = i + 1;\n            return;\n          }\n        }\n      }\n    },\n    handleUtterance: function(utterance) {\n      var lowercase = utterance.toLowerCase();\n      var utterance = Utils.removeFillerWords(lowercase).trim();\n\n      var scratch = this;\n\n      // Attempt to match utterance to trigger.\n      for (var commandType in this._triggers) {\n        var args = Utils.match(utterance, this._triggers[commandType]);\n        if (args) {\n          if (this.can(commandType)) {\n            try {\n              this[commandType](scratch, args, utterance);\n              return true;\n            } catch(e) {\n              // Handle failure based on transition type.\n              console.log(e)\n              switch (commandType) {\n                case 'editExistingProject':\n                  // If attempting to open a nonexistent project, stay in\n                  // current state.\n                  this.say(\"There's no project called \" + nameOfDesiredProject);\n                  commandType = 'stay';\n                  break;\n                case 'play':\n                  if (this.state == 'InsideProject') {\n                    if (this.currentProject.state == 'empty') {\n                      // User is trying to give a project the same name as a previous\n                      // project.\n                      this.say('You already have a project called that.')\n                    } else {\n                      // User is composing a Scratch program from other Scratch programs.\n                      var result = this.currentProject.handleUtterance(utterance);\n                    }\n                  }\n              }\n            }\n          } else {\n            console.log('could not make transition: ' + commandType);\n            console.log('current state: ' + scratch.state);\n          }\n        }\n      }\n\n      if (this.state == 'PlayProject') {\n          this.currentProject.handleUtteranceDuringExecution(utterance);\n      } else if (this.state == 'InsideProject') {\n       // Handle utterances in the InsideProject context.\n        if (this.currentProject) {\n          var result = this.currentProject.handleUtterance(utterance);\n          if (result == 'exit') {\n            this.finishProject();\n          }\n        }\n      } else if (utterance.toLowerCase().indexOf('scratch') != -1) {\n        // TODO: integrate Scratch, Help!\n        console.log('found Scratch in failed utterance');\n        this.say(\"I heard you say \" + utterance);\n        this.say(\"I don't know how to do that.\");\n      }\n    },\n    removeFromLocalStorage: function(projectName) {\n      if (window.localStorage.scratchProjects) {\n        var savedProjects = JSON.parse(window.localStorage.scratchProjects);\n        delete savedProjects[projectName];\n        window.localStorage.scratchProjects = JSON.stringify(savedProjects);\n      }\n    },\n    saveToLocalStorage: function() {\n      if (!window.localStorage.scratchProjects) {\n        window.localStorage.scratchProjects = JSON.stringify({});\n      }\n      for (var projectName in this.projects) {\n        var savedProjects = JSON.parse(window.localStorage.scratchProjects);\n        savedProjects[projectName] = this.projects[projectName].instructions;\n        window.localStorage.scratchProjects = JSON.stringify(savedProjects);\n      }\n    },\n    loadFromLocalStorage: function() {\n      if (!window.localStorage.scratchProjects) {\n        window.localStorage.scratchProjects = JSON.stringify({});\n      }\n      var savedProjects = JSON.parse(window.localStorage.scratchProjects);\n      for (var name in savedProjects) {\n        this.projects[name] = new ScratchProject(this);\n        this.projects[name].name = name;\n        this.projects[name].instructions = savedProjects[name];\n      }\n    },\n    // In order to properly detect playing projects, add project names to\n    // match phrases for the play triggerType.\n    _updatePlayRegex: function() {\n      var pattern = this._triggers['play'].toString();\n      var prefix = pattern.substring(1,pattern.length-1);\n      var regexString = prefix + '|(' + Object.keys(this.projects).map((projectName) => Utils.removeFillerWords(projectName).trim()).join(')|(') + ')';\n      this._triggers['play'] = new RegExp(regexString, \"i\");\n    },\n    updateGrammarWithProjects: () => {\n      var grammar = `#JSGF V1.0;\n      grammar scratch_state_machine.project; \\n\n      <project> =` + Object.keys(this.projects).join('|') + ';\\n';\n      this.recognition.grammars.addFromString(grammar, 1);\n    }\n  }\n});\n\nmodule.exports = ScratchStateMachine;\n\n\n//# sourceURL=webpack:///./src/scratch_state_machine.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Utility functions used across files.\n */\n\n/**\n * Namespace\n */\n Utils = {}\n\n /**\n  * Get all defined matches of string to given regular expression.\n  */\n Utils.match = (utterance, pattern) => {\n  var matches = utterance.match(pattern, \"i\");\n  return matches ? matches.filter(word => word != undefined) : null;\n }\n\n Utils.text2num = (numberWord) => {\n  var parseResult = parseInt(numberWord);\n  if (!isNaN(parseResult)) {\n    return numberWord;\n  }\n\n  var a, n, g;\n  a = numberWord.toString().split(/[\\s-]+/);\n  n = 0;\n  g = 0;\n\n  var Small = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9,\n    'ten': 10,\n    'eleven': 11,\n    'twelve': 12,\n    'thirteen': 13,\n    'fourteen': 14,\n    'fifteen': 15,\n    'sixteen': 16,\n    'seventeen': 17,\n    'eighteen': 18,\n    'nineteen': 19,\n    'twenty': 20,\n    'thirty': 30,\n    'forty': 40,\n    'fifty': 50,\n    'sixty': 60,\n    'seventy': 70,\n    'eighty': 80,\n    'ninety': 90\n  };\n\n  var Magnitude = {\n    'thousand':     1000,\n    'million':      1000000,\n    'billion':      1000000000,\n    'trillion':     1000000000000,\n    'quadrillion':  1000000000000000,\n    'quintillion':  1000000000000000000,\n    'sextillion':   1000000000000000000000,\n    'septillion':   1000000000000000000000000,\n    'octillion':    1000000000000000000000000000,\n    'nonillion':    1000000000000000000000000000000,\n    'decillion':    1000000000000000000000000000000000,\n  };\n\n  function feach(w) {\n    var x = Small[w];\n    if (x != null) {\n        g = g + x;\n    }\n    else if (w == \"hundred\") {\n        g = g * 100;\n    }\n    else {\n        x = Magnitude[w];\n        if (x != null) {\n            n = n + g * x\n            g = 0;\n        }\n        else {\n            return null;\n        }\n    }\n  }\n\n  a.forEach(feach);\n  return n + g;\n}\n\nUtils.removeFillerWords = function(utterance) {\n  var filler_words = [\"um\", \"uh\", \"er\", \"ah\", \"like\"];\n\n  var utterance = utterance.toLowerCase();\n  var stripped = utterance.replace(/\\b[-.,()&$#!\\[\\]{}\"']+\\B|\\B[-.,()&$#!\\[\\]{}\"']+\\b/g, \"\");\n  var tokens = stripped.split(' ');\n  var result = tokens.filter(token => filler_words.indexOf(token) == -1);\n  return result.join(' ');\n};\n\nmodule.exports = Utils;\n\n//# sourceURL=webpack:///./src/utils.js?");

/***/ })

/******/ });