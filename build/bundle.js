/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/prototype.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/javascript-state-machine/lib/history.js":
/*!**************************************************************!*\
  !*** ./node_modules/javascript-state-machine/lib/history.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//-------------------------------------------------------------------------------------------------\n\nfunction camelize(label) {\n\n  if (label.length === 0)\n    return label;\n\n  var n, result, word, words = label.split(/[_-]/);\n\n  // single word with first character already lowercase, return untouched\n  if ((words.length === 1) && (words[0][0].toLowerCase() === words[0][0]))\n    return label;\n\n  result = words[0].toLowerCase();\n  for(n = 1 ; n < words.length ; n++) {\n    result = result + words[n].charAt(0).toUpperCase() + words[n].substring(1).toLowerCase();\n  }\n\n  return result;\n}\n\n//-------------------------------------------------------------------------------------------------\n\ncamelize.prepended = function(prepend, label) {\n  label = camelize(label);\n  return prepend + label[0].toUpperCase() + label.substring(1);\n}\n\n//-------------------------------------------------------------------------------------------------\n\nmodule.exports = camelize;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//-------------------------------------------------------------------------------------------------\n\nvar camelize = __webpack_require__(0);\n\n//-------------------------------------------------------------------------------------------------\n\nmodule.exports = function(options) { options = options || {};\n\n  var past       = camelize(options.name || options.past   || 'history'),\n      future     = camelize(                options.future || 'future'),\n      clear      = camelize.prepended('clear', past),\n      back       = camelize.prepended(past,   'back'),\n      forward    = camelize.prepended(past,   'forward'),\n      canBack    = camelize.prepended('can',   back),\n      canForward = camelize.prepended('can',   forward),\n      max        = options.max;\n\n  var plugin = {\n\n    configure: function(config) {\n      config.addTransitionLifecycleNames(back);\n      config.addTransitionLifecycleNames(forward);\n    },\n\n    init: function(instance) {\n      instance[past]   = [];\n      instance[future] = [];\n    },\n\n    lifecycle: function(instance, lifecycle) {\n      if (lifecycle.event === 'onEnterState') {\n        instance[past].push(lifecycle.to);\n        if (max && instance[past].length > max)\n          instance[past].shift();\n        if (lifecycle.transition !== back && lifecycle.transition !== forward)\n          instance[future].length = 0;\n      }\n    },\n\n    methods:    {},\n    properties: {}\n\n  }\n\n  plugin.methods[clear] = function() {\n    this[past].length = 0\n    this[future].length = 0\n  }\n\n  plugin.properties[canBack] = {\n    get: function() {\n      return this[past].length > 1\n    }\n  }\n\n  plugin.properties[canForward] = {\n    get: function() {\n      return this[future].length > 0\n    }\n  }\n\n  plugin.methods[back] = function() {\n    if (!this[canBack])\n      throw Error('no history');\n    var from = this[past].pop(),\n        to   = this[past].pop();\n    this[future].push(from);\n    this._fsm.transit(back, from, to, []);\n  }\n\n  plugin.methods[forward] = function() {\n    if (!this[canForward])\n      throw Error('no history');\n    var from = this.state,\n        to = this[future].pop();\n    this._fsm.transit(forward, from, to, []);\n  }\n\n  return plugin;\n\n}\n\n\n/***/ })\n/******/ ]);\n});\n\n//# sourceURL=webpack:///./node_modules/javascript-state-machine/lib/history.js?");

/***/ }),

/***/ "./node_modules/javascript-state-machine/lib/state-machine.js":
/*!********************************************************************!*\
  !*** ./node_modules/javascript-state-machine/lib/state-machine.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(target, sources) {\n  var n, source, key;\n  for(n = 1 ; n < arguments.length ; n++) {\n    source = arguments[n];\n    for(key in source) {\n      if (source.hasOwnProperty(key))\n        target[key] = source[key];\n    }\n  }\n  return target;\n}\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//-------------------------------------------------------------------------------------------------\n\nvar mixin = __webpack_require__(0);\n\n//-------------------------------------------------------------------------------------------------\n\nmodule.exports = {\n\n  build: function(target, config) {\n    var n, max, plugin, plugins = config.plugins;\n    for(n = 0, max = plugins.length ; n < max ; n++) {\n      plugin = plugins[n];\n      if (plugin.methods)\n        mixin(target, plugin.methods);\n      if (plugin.properties)\n        Object.defineProperties(target, plugin.properties);\n    }\n  },\n\n  hook: function(fsm, name, additional) {\n    var n, max, method, plugin,\n        plugins = fsm.config.plugins,\n        args    = [fsm.context];\n\n    if (additional)\n      args = args.concat(additional)\n\n    for(n = 0, max = plugins.length ; n < max ; n++) {\n      plugin = plugins[n]\n      method = plugins[n][name]\n      if (method)\n        method.apply(plugin, args);\n    }\n  }\n\n}\n\n//-------------------------------------------------------------------------------------------------\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//-------------------------------------------------------------------------------------------------\n\nfunction camelize(label) {\n\n  if (label.length === 0)\n    return label;\n\n  var n, result, word, words = label.split(/[_-]/);\n\n  // single word with first character already lowercase, return untouched\n  if ((words.length === 1) && (words[0][0].toLowerCase() === words[0][0]))\n    return label;\n\n  result = words[0].toLowerCase();\n  for(n = 1 ; n < words.length ; n++) {\n    result = result + words[n].charAt(0).toUpperCase() + words[n].substring(1).toLowerCase();\n  }\n\n  return result;\n}\n\n//-------------------------------------------------------------------------------------------------\n\ncamelize.prepended = function(prepend, label) {\n  label = camelize(label);\n  return prepend + label[0].toUpperCase() + label.substring(1);\n}\n\n//-------------------------------------------------------------------------------------------------\n\nmodule.exports = camelize;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//-------------------------------------------------------------------------------------------------\n\nvar mixin    = __webpack_require__(0),\n    camelize = __webpack_require__(2);\n\n//-------------------------------------------------------------------------------------------------\n\nfunction Config(options, StateMachine) {\n\n  options = options || {};\n\n  this.options     = options; // preserving original options can be useful (e.g visualize plugin)\n  this.defaults    = StateMachine.defaults;\n  this.states      = [];\n  this.transitions = [];\n  this.map         = {};\n  this.lifecycle   = this.configureLifecycle();\n  this.init        = this.configureInitTransition(options.init);\n  this.data        = this.configureData(options.data);\n  this.methods     = this.configureMethods(options.methods);\n\n  this.map[this.defaults.wildcard] = {};\n\n  this.configureTransitions(options.transitions || []);\n\n  this.plugins = this.configurePlugins(options.plugins, StateMachine.plugin);\n\n}\n\n//-------------------------------------------------------------------------------------------------\n\nmixin(Config.prototype, {\n\n  addState: function(name) {\n    if (!this.map[name]) {\n      this.states.push(name);\n      this.addStateLifecycleNames(name);\n      this.map[name] = {};\n    }\n  },\n\n  addStateLifecycleNames: function(name) {\n    this.lifecycle.onEnter[name] = camelize.prepended('onEnter', name);\n    this.lifecycle.onLeave[name] = camelize.prepended('onLeave', name);\n    this.lifecycle.on[name]      = camelize.prepended('on',      name);\n  },\n\n  addTransition: function(name) {\n    if (this.transitions.indexOf(name) < 0) {\n      this.transitions.push(name);\n      this.addTransitionLifecycleNames(name);\n    }\n  },\n\n  addTransitionLifecycleNames: function(name) {\n    this.lifecycle.onBefore[name] = camelize.prepended('onBefore', name);\n    this.lifecycle.onAfter[name]  = camelize.prepended('onAfter',  name);\n    this.lifecycle.on[name]       = camelize.prepended('on',       name);\n  },\n\n  mapTransition: function(transition) {\n    var name = transition.name,\n        from = transition.from,\n        to   = transition.to;\n    this.addState(from);\n    if (typeof to !== 'function')\n      this.addState(to);\n    this.addTransition(name);\n    this.map[from][name] = transition;\n    return transition;\n  },\n\n  configureLifecycle: function() {\n    return {\n      onBefore: { transition: 'onBeforeTransition' },\n      onAfter:  { transition: 'onAfterTransition'  },\n      onEnter:  { state:      'onEnterState'       },\n      onLeave:  { state:      'onLeaveState'       },\n      on:       { transition: 'onTransition'       }\n    };\n  },\n\n  configureInitTransition: function(init) {\n    if (typeof init === 'string') {\n      return this.mapTransition(mixin({}, this.defaults.init, { to: init, active: true }));\n    }\n    else if (typeof init === 'object') {\n      return this.mapTransition(mixin({}, this.defaults.init, init, { active: true }));\n    }\n    else {\n      this.addState(this.defaults.init.from);\n      return this.defaults.init;\n    }\n  },\n\n  configureData: function(data) {\n    if (typeof data === 'function')\n      return data;\n    else if (typeof data === 'object')\n      return function() { return data; }\n    else\n      return function() { return {};  }\n  },\n\n  configureMethods: function(methods) {\n    return methods || {};\n  },\n\n  configurePlugins: function(plugins, builtin) {\n    plugins = plugins || [];\n    var n, max, plugin;\n    for(n = 0, max = plugins.length ; n < max ; n++) {\n      plugin = plugins[n];\n      if (typeof plugin === 'function')\n        plugins[n] = plugin = plugin()\n      if (plugin.configure)\n        plugin.configure(this);\n    }\n    return plugins\n  },\n\n  configureTransitions: function(transitions) {\n    var i, n, transition, from, to, wildcard = this.defaults.wildcard;\n    for(n = 0 ; n < transitions.length ; n++) {\n      transition = transitions[n];\n      from  = Array.isArray(transition.from) ? transition.from : [transition.from || wildcard]\n      to    = transition.to || wildcard;\n      for(i = 0 ; i < from.length ; i++) {\n        this.mapTransition({ name: transition.name, from: from[i], to: to });\n      }\n    }\n  },\n\n  transitionFor: function(state, transition) {\n    var wildcard = this.defaults.wildcard;\n    return this.map[state][transition] ||\n           this.map[wildcard][transition];\n  },\n\n  transitionsFor: function(state) {\n    var wildcard = this.defaults.wildcard;\n    return Object.keys(this.map[state]).concat(Object.keys(this.map[wildcard]));\n  },\n\n  allStates: function() {\n    return this.states;\n  },\n\n  allTransitions: function() {\n    return this.transitions;\n  }\n\n});\n\n//-------------------------------------------------------------------------------------------------\n\nmodule.exports = Config;\n\n//-------------------------------------------------------------------------------------------------\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\nvar mixin      = __webpack_require__(0),\n    Exception  = __webpack_require__(6),\n    plugin     = __webpack_require__(1),\n    UNOBSERVED = [ null, [] ];\n\n//-------------------------------------------------------------------------------------------------\n\nfunction JSM(context, config) {\n  this.context   = context;\n  this.config    = config;\n  this.state     = config.init.from;\n  this.observers = [context];\n}\n\n//-------------------------------------------------------------------------------------------------\n\nmixin(JSM.prototype, {\n\n  init: function(args) {\n    mixin(this.context, this.config.data.apply(this.context, args));\n    plugin.hook(this, 'init');\n    if (this.config.init.active)\n      return this.fire(this.config.init.name, []);\n  },\n\n  is: function(state) {\n    return Array.isArray(state) ? (state.indexOf(this.state) >= 0) : (this.state === state);\n  },\n\n  isPending: function() {\n    return this.pending;\n  },\n\n  can: function(transition) {\n    return !this.isPending() && !!this.seek(transition);\n  },\n\n  cannot: function(transition) {\n    return !this.can(transition);\n  },\n\n  allStates: function() {\n    return this.config.allStates();\n  },\n\n  allTransitions: function() {\n    return this.config.allTransitions();\n  },\n\n  transitions: function() {\n    return this.config.transitionsFor(this.state);\n  },\n\n  seek: function(transition, args) {\n    var wildcard = this.config.defaults.wildcard,\n        entry    = this.config.transitionFor(this.state, transition),\n        to       = entry && entry.to;\n    if (typeof to === 'function')\n      return to.apply(this.context, args);\n    else if (to === wildcard)\n      return this.state\n    else\n      return to\n  },\n\n  fire: function(transition, args) {\n    return this.transit(transition, this.state, this.seek(transition, args), args);\n  },\n\n  transit: function(transition, from, to, args) {\n\n    var lifecycle = this.config.lifecycle,\n        changed   = this.config.options.observeUnchangedState || (from !== to);\n\n    if (!to)\n      return this.context.onInvalidTransition(transition, from, to);\n\n    if (this.isPending())\n      return this.context.onPendingTransition(transition, from, to);\n\n    this.config.addState(to);  // might need to add this state if it's unknown (e.g. conditional transition or goto)\n\n    this.beginTransit();\n\n    args.unshift({             // this context will be passed to each lifecycle event observer\n      transition: transition,\n      from:       from,\n      to:         to,\n      fsm:        this.context\n    });\n\n    return this.observeEvents([\n                this.observersForEvent(lifecycle.onBefore.transition),\n                this.observersForEvent(lifecycle.onBefore[transition]),\n      changed ? this.observersForEvent(lifecycle.onLeave.state) : UNOBSERVED,\n      changed ? this.observersForEvent(lifecycle.onLeave[from]) : UNOBSERVED,\n                this.observersForEvent(lifecycle.on.transition),\n      changed ? [ 'doTransit', [ this ] ]                       : UNOBSERVED,\n      changed ? this.observersForEvent(lifecycle.onEnter.state) : UNOBSERVED,\n      changed ? this.observersForEvent(lifecycle.onEnter[to])   : UNOBSERVED,\n      changed ? this.observersForEvent(lifecycle.on[to])        : UNOBSERVED,\n                this.observersForEvent(lifecycle.onAfter.transition),\n                this.observersForEvent(lifecycle.onAfter[transition]),\n                this.observersForEvent(lifecycle.on[transition])\n    ], args);\n  },\n\n  beginTransit: function()          { this.pending = true;                 },\n  endTransit:   function(result)    { this.pending = false; return result; },\n  failTransit:  function(result)    { this.pending = false; throw result;  },\n  doTransit:    function(lifecycle) { this.state = lifecycle.to;           },\n\n  observe: function(args) {\n    if (args.length === 2) {\n      var observer = {};\n      observer[args[0]] = args[1];\n      this.observers.push(observer);\n    }\n    else {\n      this.observers.push(args[0]);\n    }\n  },\n\n  observersForEvent: function(event) { // TODO: this could be cached\n    var n = 0, max = this.observers.length, observer, result = [];\n    for( ; n < max ; n++) {\n      observer = this.observers[n];\n      if (observer[event])\n        result.push(observer);\n    }\n    return [ event, result, true ]\n  },\n\n  observeEvents: function(events, args, previousEvent, previousResult) {\n    if (events.length === 0) {\n      return this.endTransit(previousResult === undefined ? true : previousResult);\n    }\n\n    var event     = events[0][0],\n        observers = events[0][1],\n        pluggable = events[0][2];\n\n    args[0].event = event;\n    if (event && pluggable && event !== previousEvent)\n      plugin.hook(this, 'lifecycle', args);\n\n    if (observers.length === 0) {\n      events.shift();\n      return this.observeEvents(events, args, event, previousResult);\n    }\n    else {\n      var observer = observers.shift(),\n          result = observer[event].apply(observer, args);\n      if (result && typeof result.then === 'function') {\n        return result.then(this.observeEvents.bind(this, events, args, event))\n                     .catch(this.failTransit.bind(this))\n      }\n      else if (result === false) {\n        return this.endTransit(false);\n      }\n      else {\n        return this.observeEvents(events, args, event, result);\n      }\n    }\n  },\n\n  onInvalidTransition: function(transition, from, to) {\n    throw new Exception(\"transition is invalid in current state\", transition, from, to, this.state);\n  },\n\n  onPendingTransition: function(transition, from, to) {\n    throw new Exception(\"transition is invalid while previous transition is still in progress\", transition, from, to, this.state);\n  }\n\n});\n\n//-------------------------------------------------------------------------------------------------\n\nmodule.exports = JSM;\n\n//-------------------------------------------------------------------------------------------------\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//-----------------------------------------------------------------------------------------------\n\nvar mixin    = __webpack_require__(0),\n    camelize = __webpack_require__(2),\n    plugin   = __webpack_require__(1),\n    Config   = __webpack_require__(3),\n    JSM      = __webpack_require__(4);\n\n//-----------------------------------------------------------------------------------------------\n\nvar PublicMethods = {\n  is:                  function(state)       { return this._fsm.is(state)                                     },\n  can:                 function(transition)  { return this._fsm.can(transition)                               },\n  cannot:              function(transition)  { return this._fsm.cannot(transition)                            },\n  observe:             function()            { return this._fsm.observe(arguments)                            },\n  transitions:         function()            { return this._fsm.transitions()                                 },\n  allTransitions:      function()            { return this._fsm.allTransitions()                              },\n  allStates:           function()            { return this._fsm.allStates()                                   },\n  onInvalidTransition: function(t, from, to) { return this._fsm.onInvalidTransition(t, from, to)              },\n  onPendingTransition: function(t, from, to) { return this._fsm.onPendingTransition(t, from, to)              },\n}\n\nvar PublicProperties = {\n  state: {\n    configurable: false,\n    enumerable:   true,\n    get: function() {\n      return this._fsm.state;\n    },\n    set: function(state) {\n      throw Error('use transitions to change state')\n    }\n  }\n}\n\n//-----------------------------------------------------------------------------------------------\n\nfunction StateMachine(options) {\n  return apply(this || {}, options);\n}\n\nfunction factory() {\n  var cstor, options;\n  if (typeof arguments[0] === 'function') {\n    cstor   = arguments[0];\n    options = arguments[1] || {};\n  }\n  else {\n    cstor   = function() { this._fsm.apply(this, arguments) };\n    options = arguments[0] || {};\n  }\n  var config = new Config(options, StateMachine);\n  build(cstor.prototype, config);\n  cstor.prototype._fsm.config = config; // convenience access to shared config without needing an instance\n  return cstor;\n}\n\n//-------------------------------------------------------------------------------------------------\n\nfunction apply(instance, options) {\n  var config = new Config(options, StateMachine);\n  build(instance, config);\n  instance._fsm();\n  return instance;\n}\n\nfunction build(target, config) {\n  if ((typeof target !== 'object') || Array.isArray(target))\n    throw Error('StateMachine can only be applied to objects');\n  plugin.build(target, config);\n  Object.defineProperties(target, PublicProperties);\n  mixin(target, PublicMethods);\n  mixin(target, config.methods);\n  config.allTransitions().forEach(function(transition) {\n    target[camelize(transition)] = function() {\n      return this._fsm.fire(transition, [].slice.call(arguments))\n    }\n  });\n  target._fsm = function() {\n    this._fsm = new JSM(this, config);\n    this._fsm.init(arguments);\n  }\n}\n\n//-----------------------------------------------------------------------------------------------\n\nStateMachine.version  = '3.0.1';\nStateMachine.factory  = factory;\nStateMachine.apply    = apply;\nStateMachine.defaults = {\n  wildcard: '*',\n  init: {\n    name: 'init',\n    from: 'none'\n  }\n}\n\n//===============================================================================================\n\nmodule.exports = StateMachine;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(message, transition, from, to, current) {\n  this.message    = message;\n  this.transition = transition;\n  this.from       = from;\n  this.to         = to;\n  this.current    = current;\n}\n\n\n/***/ })\n/******/ ]);\n});\n\n//# sourceURL=webpack:///./node_modules/javascript-state-machine/lib/state-machine.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/prototype.js":
/*!**************************!*\
  !*** ./src/prototype.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * @fileoverview\n *\n * JavaScript for the Scratch Voice User Interface prototype.\n * @author Tina Quach (quacht@mit.edu)\n */\nglobal.ScratchStateMachine = __webpack_require__(/*! ./scratch_state_machine.js */ \"./src/scratch_state_machine.js\");\n\nglobal.scratch = new ScratchStateMachine();\n\nscratch.observe('onAfterTransition', function() {\n  document.getElementById(\"current_state\").innerHTML = scratch.state;\n});\n\nglobal.final_transcript = '';\nglobal.recognizing = false;\nglobal.ignore_onend;\nglobal.start_timestamp;\n\nglobal.upgrade = function() {\n  start_button.style.visibility = 'hidden';\n  showInfo('info_upgrade');\n}\n\nglobal.two_line = /\\n\\n/g;\nglobal.one_line = /\\n/g;\nglobal.linebreak = function(s) {\n  return s.replace(two_line, '<p></p>').replace(one_line, '<br>');\n}\n\nglobal.first_char = /\\S/;\nglobal.capitalize = function(s) {\n  return s.replace(first_char, function(m) { return m.toUpperCase(); });\n}\n\ndocument.getElementById(\"start_button\").onclick =  function(event) {\n  if (recognizing) {\n    recognition.stop();\n    return;\n  }\n  final_transcript = '';\n  recognition.start();\n  ignore_onend = false;\n  final_span.innerHTML = '';\n  interim_span.innerHTML = '';\n  start_img.src = 'assets/mic-slash.gif';\n  showInfo('info_allow');\n  showButtons('none');\n  start_timestamp = event.timeStamp;\n}\n\nglobal.showInfo = function(s) {\n  if (s) {\n    for (var child = info.firstChild; child; child = child.nextSibling) {\n      if (child.style) {\n        child.style.display = child.id == s ? 'inline' : 'none';\n      }\n    }\n    info.style.visibility = 'visible';\n  } else {\n    info.style.visibility = 'hidden';\n  }\n}\n\nglobal.current_style;\nglobal.showButtons = function(style) {\n  if (style == global.current_style) {\n    return;\n  }\n  global.current_style = style;\n}\n\nif (!('webkitSpeechRecognition' in window)) {\n  upgrade();\n} else {\n  start_button.style.display = 'inline-block';\n  global.recognition = scratch.pm.recognition;\n  recognition.continuous = true;\n  recognition.interimResults = true;\n\n  recognition.onstart = function() {\n    recognizing = true;\n    showInfo('info_speak_now');\n    start_img.src = 'assets/mic-animate.gif';\n  };\n\n  recognition.onerror = function(event) {\n    if (event.error == 'no-speech') {\n      start_img.src = 'assets/mic.gif';\n      showInfo('info_no_speech');\n      ignore_onend = true;\n    }\n    if (event.error == 'audio-capture') {\n      start_img.src = 'assets/mic.gif';\n      showInfo('info_no_microphone');\n      ignore_onend = true;\n    }\n    if (event.error == 'not-allowed') {\n      if (event.timeStamp - start_timestamp < 100) {\n        showInfo('info_blocked');\n      } else {\n        showInfo('info_denied');\n      }\n      ignore_onend = true;\n    }\n  };\n\n  recognition.onend = function() {\n    recognizing = false;\n    if (ignore_onend) {\n      return;\n    }\n    start_img.src = 'assets/mic.gif';\n    if (!final_transcript) {\n      showInfo('info_start');\n      return;\n    }\n    showInfo('');\n    if (window.getSelection) {\n      window.getSelection().removeAllRanges();\n      global.range = document.createRange();\n      range.selectNode(document.getElementById('final_span'));\n      window.getSelection().addRange(range);\n    }\n\n  };\n\n  // Since recognition is continuous, we will get interim results based on the\n  // partial utterance.\n  // The API still helps us recognize when a pause has occured.\n  recognition.onresult = function(event) {\n    global.interim_transcript = '';\n    for (global.i = event.resultIndex; i < event.results.length; ++i) {\n      if (event.results[i].isFinal) {\n        final_transcript = event.results[i][0].transcript;\n        console.log(event.results[i][0].transcript)\n        // Analyze utterance.\n        scratch.handleUtterance(event.results[i][0].transcript)\n      } else {\n        interim_transcript += event.results[i][0].transcript;\n      }\n    }\n\n    final_transcript = capitalize(final_transcript);\n    final_span.innerHTML = linebreak(final_transcript);\n    interim_span.innerHTML = linebreak(interim_transcript);\n    if (final_transcript || interim_transcript) {\n      showButtons('inline-block');\n    }\n  };\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/prototype.js?");

/***/ }),

/***/ "./src/scratch_instruction.js":
/*!************************************!*\
  !*** ./src/scratch_instruction.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Define ScratchInstruction class for converting sentences\n * to Scratch programs\n * @author Tina Quach (quacht@mit.edu)\n */\n\n/**\n * ScratchInstruction class\n */\nclass ScratchInstruction {\n  /**\n   * Constructor for the ScratchInstruction\n   * @param {!String} rawInstruction - the utterance from the user.\n   * @param {!ScratchAction} action - the action to which this instruction\n   *    belongs.\n   */\n  constructor(rawInstruction) {\n    this.raw = rawInstruction.trim();\n    try {\n      this.steps = this.getSteps();\n    } catch(e) {\n      this.steps = null;\n    }\n  }\n\n  /**\n   * Get the sentences in the instruction that use undefined actions.\n   * @param {!String} instruction - String containing the instruction\n   * @return {!Array<!String>} an array of unsupported sentences.\n   */\n  static getUnsupportedSteps(instruction) {\n    // Detect multiple statements and split them.\n    let sentences = instruction.replace(/([.?!])\\s*(?=[A-Z])/g, \"$1|\").split(\"|\");\n    var unknownActions = [];\n    for (var i = 0; i < sentences.length; i++) {\n      try {\n        var instructionJson = ScratchInstruction.extractArgs(sentences[i]);\n        var scratchInstruction = ScratchInstruction.jsonToScratch(instructionJson);\n      } catch (e) {\n        unknownActions.push(sentences[i]);\n      }\n    }\n    return unknownActions;\n  }\n\n  /**\n   * Returns the steps of the Scratch program.\n   */\n  getSteps() {\n    // Detect multiple statements and split them.\n    let sentences = this.raw.replace(/([.?!])\\s*(?=[A-Z])/g, \"$1|\").split(\"|\");\n    var steps = [];\n    for (var i = 0; i < sentences.length; i++) {\n      try {\n        var instructionJson = ScratchInstruction.extractArgs(sentences[i]);\n        var scratchInstruction = ScratchInstruction.jsonToScratch(instructionJson);\n        steps.push(scratchInstruction);\n      } catch (e) {\n        console.log(e);\n        throw new Error(\"Failed to get steps from instruction: \" + this.raw);\n      }\n    }\n    return steps;\n  }\n\n  /**\n   * Helper function for getSteps. Returns a JSON representing the instruction.\n   * @param {!String} instruction A sentence that may contain a command.\n   * @return JSON object encoding information for generating Scratch program.\n   */\n  static extractArgs(sentence) {\n    sentence = sentence.trim();\n    var instructionJson = {\n      original: sentence\n    };\n\n    if (!sentence) {\n      return instructionJson;\n    }\n\n    let commandTemplates = {\n      'when EVENT, you CMD': /[wW]hen (.*),? you (.*)/,\n      'then/next/after, CMD': /([Tt]hen|[nN]ext|[aA]fter),? (.*)/,\n      'first, CMD': /[fF]irst,? (.*)/,\n    };\n    var keys = Object.keys(commandTemplates);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var matches = Utils.match(sentence, commandTemplates[key]);\n      if (matches) {\n        switch (key) {\n          case 'when EVENT, you CMD':\n            instructionJson.event = matches[1];\n            instructionJson.command = matches[2];\n            return instructionJson;\n          case 'then/next/after, CMD':\n            instructionJson.event = 'after last command';\n            instructionJson.command = matches[2];\n            return instructionJson;\n          case 'first, CMD':\n            instructionJson.event = 'first';\n            instructionJson.command = matches[1];\n            return instructionJson;\n        }\n      }\n    }\n\n    instructionJson.command = sentence;\n\n    return instructionJson;\n  }\n\n  /**\n   * Helper function for getSteps. Returns a JSON representing the instruction.\n   * @param {!String} instruction A sentence that may contain a command.\n   */\n  static jsonToScratch(instructionJson) {\n    if (!instructionJson.command) {\n      return null;\n    }\n\n    // Process command.\n    var instructionTokens = instructionJson.command.split(' ');\n    if (instructionTokens) {\n      // Assume first word is the verb and the rest of the command is an\n      // argument.\n      var verb = instructionTokens[0];\n\n      // Check for all built in commands, mapped to Scratch programs.\n      // TODO: add more cases to handle wider variety of possible scratch\n      // commands.\n      if (verb.toLowerCase() === 'say') {\n        var opcode = 'say:';\n      } else {\n        // Verb is not recognized\n        throw new Error(\"Scratch does not know how to '\" + verb + \"'\");\n      }\n      var command = [opcode, instructionTokens.slice(1).join(' ')];\n    }\n\n    if (instructionJson.event) {\n      if (instructionJson.event.toLowerCase().startsWith('i say')) {\n        let argument = instructionJson.event.substring(6);\n        command = [[\"doAsk\", \"\"],[\"doIf\", [\"=\", [\"answer\"], argument], [command]]];\n      }\n      // else if (instructionJson.event == 'first') {\n      //   // TODO: Need some way to pass this information to Scratch model for building the progam.\n      // } else if (instructionJson.event == 'after last command') {\n      //   // TODO: Need some way to pass this information to Scratch model for building the progam.\n      // }\n    }\n\n    return command;\n  }\n}\n\nmodule.exports = ScratchInstruction;\n\n//# sourceURL=webpack:///./src/scratch_instruction.js?");

/***/ }),

/***/ "./src/scratch_project.js":
/*!********************************!*\
  !*** ./src/scratch_project.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Defines the ScratchProject object as a JavaScript state\n * machine.\n *\n * @author quacht@mit.edu (Tina Quach)\n */\nvar StateMachine = __webpack_require__(/*! javascript-state-machine */ \"./node_modules/javascript-state-machine/lib/state-machine.js\");\nconst ScratchInstruction = __webpack_require__(/*! ./scratch_instruction.js */ \"./src/scratch_instruction.js\");\nconst Utils = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n\n\n// TODO: idea: move the edit commands to the state machine level instead of the\n// scratch project level, since we manage what the currentproject is.\n// to resolve the issue of this referring to the wrong this.\n\nvar ScratchProject = StateMachine.factory({\n  init: 'create',\n  transitions: [\n    // Support linear project creation process.\n    { name: 'startProjectCreation', from: 'create', to: 'empty'},\n    { name: 'nameProject', from: 'empty', to: 'named'},\n    { name: 'addInstruction', from: 'named', to: 'nonempty'},\n    { name: 'addInstruction', from: 'nonempty', to: 'nonempty'},\n    { name: 'finishProject', from: 'nonempty', to: 'nonempty'},\n    { name: 'finishProject', from: '*', to: (s) => { return s} },\n    { name: 'goto', from: '*', to: function(s) { return s } }\n  ],\n  data: function(pm) {\n    return {\n      pm: pm,\n      ssm: pm.ssm,\n      name: null,\n      instructions: [],\n      // TODO: deal with 1 versus 0 based indexing.\n      // TODO: handle word forms of words in referencing steps.\n      instructionPointer: null,\n      editTriggers: {\n        goToStep: /go to step (.*)|what's step (.*)|what is step (.*)/,\n        nextStep: /go to next step|next step|what's next/,\n        previousStep: /previous step|go back a step/,\n        playStep: /play step|play current step|what does it do/,\n        insertStepBefore: /insert (.*) before step (.*)|(.*) before step (.*)/,\n        insertStepAfter: /insert (.*) after step (.*)|(.*) after step (.*)/,\n        deleteStep: /delete step (.*)/,\n        // TODO: distinguish between replacing everywhere and replacing in a\n        // specific place.\n        replaceStep: /replace step (.*) with (.*)/,\n        replaceSound: /replace the (.*) sound with the (.*) sound'/,\n        // TODO: address potential complex behavior in line below.\n        replaceInStep: /in step (.*) replace (.*) with (.*)/,\n        stopEditing: /stop|i\\'m done|that\\'s it'/\n      },\n      editCommands: {\n        _describeCurrentStep: () => {\n          // this does not refer to the state machine, but to the editCommands\n          // object holding these functions.\n          if (0 < this.instructionPointer &&\n              this.instructionPointer <= this.instructions.length) {\n            this.pm.say('Step ' + this.instructionPointer);\n            this.pm.say(this.instructions[this.instructionPointer-1].raw)\n            return true;\n          } else {\n            return false;\n          }\n        },\n        goToStep: (args) => {\n          this.instructionPointer = Utils.text2num(args[1]);\n          if (this.instructionPointer == null) {\n            this.instructionPointer = parseInt(args[1]);\n          }\n          if (!this.editCommands._describeCurrentStep()) {\n            this.pm.say('there is no step ' + this.instructionPointer);\n          }\n        },\n        nextStep: () => {\n          this.instructionPointer++;\n          if (this.instructionPointer <= this.instructions.length) {\n            this.editCommands._describeCurrentStep();\n          } else {\n            this.instructionPointer--;\n            this.pm.say('No more steps');\n          }\n        },\n        previousStep: () => {\n          this.instructionPointer--;\n          if (this.instructionPointer > 0) {\n            this.editCommands._describeCurrentStep();\n          } else {\n            this.instructionPointer++;\n            this.pm.say('No more steps');\n          }\n        },\n\n        // todo - test below\n        playStep: function() {\n          var steps = this.instructions[this.instructionPointer-1].getSteps();\n          // Assuming that the project can only be made of 'say' instructions\n          for (var i = 0; i < steps.length; i++) {\n            this.pm.say(steps[i][1]);\n          }\n        },\n        insertStepBefore: function(args) {\n          // TODO: use try catch to handle inability to convert the Scratch\n          // instruction.\n          var stepToInsert = new ScratchInstruction(args[1]);\n          var referenceStepNumber = Utils.text2num(args[2])-1;\n          if (referenceStepNumber == null) {\n            referenceStepNumber = parseInt(args[2])-1;\n          }\n          this.instructions.splice(referenceStepNumber, 0, stepToInsert);\n          this.instructionPointer = referenceStepNumber;\n          console.log(this.instructions);\n        },\n        insertStepAfter: function(args) {\n          var stepToInsert = new ScratchInstruction(args[1]);\n          var referenceStepNumber = Utils.text2num(args[2])-1;\n          if (referenceStepNumber == null) {\n            referenceStepNumber = parseInt(args[2])-1;\n          }\n          this.instructions.splice(referenceStepNumber + 1, 0, stepToInsert);\n          this.instructionPointer = referenceStepNumber + 1;\n          this.pm.say('inserted step');\n          console.log(this.instructions);\n        },\n        deleteStep: function(args) {\n          console.log(this);\n          var index = Utils.text2num(args[1])-1;\n          if (index == null) {\n            index = parseInt(args[1])-1;\n          }\n          var removedScratchInstruction = this.instructions.splice(index, 1);\n          this.pm.say('Removed step ' + (index+1));\n          console.log(this.instructions);\n        },\n        replaceStep: function(args) {\n          var index = Utils.text2num(args[1])-1;\n          if (index == null) {\n            index = parseInt(args[1])-1;\n          }\n          var step = new ScratchInstruction(args[2]);\n          if (!step) {\n            this.pm.say(step + 'is not a Scratch command');\n          }\n          this.instructions.splice(index, 1, step);\n          this.pm.say('replaced step ' + (index+1));\n          console.log(this.instructions);\n        },\n        replaceInStep: function(args) {\n          var index = Utils.text2num(args[1])-1;\n          if (index == null) {\n            index = parseInt(args[1])-1;\n          }\n          var oldWord = args[2];\n          var newWord = args[3];\n          var instructionToModify = this.instructions[index];\n          // TODO: determine how to replace things w/in a step.\n        },\n        replaceSound: function(args) {\n          var oldSound = args[1];\n          var newSound = args[2];\n          // TODO: how does sound work in Scratch Programs.\n        }\n      }\n    }\n  },\n  methods: {\n    onEmpty: () => {\n      console.log('yo im an empty project')\n    },\n    onStartProjectCreation() {\n      var project = this;\n      return new Promise(function(resolve, reject) {\n        project.pm.say('What do you want to call it?');\n        resolve();\n      });\n    },\n    onNameProject: function() {\n      var project = this;\n      return new Promise(function(resolve, reject) {\n        // problem w/ using this.name is that this refers to the window--NOT to the scratch project.\n        project.pm.say('Okay. When you say, Scratch, ' + this.name + ', I’ll play the project. What’s the first step?');\n        resolve();\n      })\n    },\n    onAddInstruction: function(utterance) {\n      var project = this;\n      return new Promise(function(resolve, reject) {\n        project.pm.say('Okay, what’s the next step?');\n        resolve();\n      })\n    },\n    onFinishProject: function(utterance) {\n      var project = this;\n      return new Promise(function(resolve, reject) {\n        project.pm.say('Cool, now you can say, Scratch, ' + this.name + ', to play the project.');\n        resolve();\n      })\n    },\n    /**\n     * Return Scratch program.\n     * @return {Array<Array>} Scratch program generated from instructions\n     */\n    getScratchProgram: function() {\n      let steps = this.instructions.map(instruction => instruction.steps[0]);\n      // Everytime you want to execute the program, you add a\n      // when green flag block to start it.\n      return [['whenGreenFlag']].concat(steps);\n    },\n    _getName: function(utterance) {\n      var pattern = /call the project(.*)/;\n      var matches = Utils.match(utterance, pattern);\n      if (matches && matches.length > 0) {\n        return matches[1].trim();\n      } else {\n        return utterance.trim();\n      }\n    },\n    handleUtterance: function(utterance) {\n      utterance = Utils.removeFillerWords(utterance.toLowerCase()).trim();\n\n      // Name project\n      if (this.state == 'create') {\n        if (this.name) {\n          this.goto('named');\n        } else {\n          this.startProjectCreation();\n        }\n      }\n      if (this.state == 'empty') {\n        this.name = this._getName(utterance);\n        this.pm.projects[this.name] = this.pm.currentProject;\n        delete this.pm.projects['Untitled-'+this.pm.untitledCount];\n        this.nameProject();\n      // Add to or finish project.\n      } else if (this.state == 'named' || this.state == 'nonempty') {\n        // Detect project completion.\n        if (utterance.indexOf(\"that's it\") != -1) {\n          this.finishProject(this.state);\n          return 'exit';\n        }\n\n        // Detect and handle explicit edit commands.\n        if (this._handleEditCommands(utterance)) {\n          return;\n        }\n\n        // Parse instruction to add as a last result.\n        var instruction = new ScratchInstruction(utterance);\n        if (instruction.steps != null) {\n          this.instructions.push(instruction);\n          this.addInstruction();\n        } else {\n          this.pm.say(\"I heard you say \" + utterance);\n          this.pm.say(\"That doesn't match any Scratch commands.\");\n        }\n      }\n    },\n    handleUtteranceDuringExecution: function(utterance) {\n      var scratchProject = this;\n      if (utterance == 'scratch stop') {\n        this.synth.cancel();\n      } else if (utterance == 'scratch pause') {\n        this.synth.pause();\n      } else if (utterance == 'scratch resume' || utterance == 'scratch unpause') {\n        this.synth.resume();\n      } else {\n        // Utterance should be an argument for the project.\n        if (utterance == this.tempTrigger) {\n          this.pm.say(this.tempResponse)\n          this.pm.executeCurrentProject(scratch, 'WhereItLeftOff');\n        }\n      }\n    },\n    /**\n     * If the utterance matches the form of a supported program editing\n     * command, execute the command.\n     */\n    _handleEditCommands: function(utterance) {\n      utterance = Utils.removeFillerWords(utterance.toLowerCase());\n\n      var scratchProject = this;\n      for (var commandType in this.editTriggers) {\n        var args = Utils.match(utterance, this.editTriggers[commandType]);\n        if (args) {\n          this.editCommands[commandType].call(scratchProject, args);\n          this.pm.save();\n          return true;\n        }\n      }\n    }\n  }\n});\n\nmodule.exports = ScratchProject;\n\n//# sourceURL=webpack:///./src/scratch_project.js?");

/***/ }),

/***/ "./src/scratch_project_manager.js":
/*!****************************************!*\
  !*** ./src/scratch_project_manager.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview attempt to factor out the methods from the Scratch State Machine.\n */\n\nconst ScratchProject = __webpack_require__(/*! ./scratch_project.js */ \"./src/scratch_project.js\");\nconst ScratchStateMachine = __webpack_require__(/*! ./scratch_state_machine.js */ \"./src/scratch_state_machine.js\");\nconst ScratchStorage = __webpack_require__(/*! ./storage.js */ \"./src/storage.js\");\nconst ScratchRegex = __webpack_require__(/*! ./triggers.js */ \"./src/triggers.js\");\n\n/**\n * ScratchProjectManager class\n */\nclass ScratchProjectManager {\n\n\t/**\n\t * Constructor for ScratchProjectManager\n\t */\n\tconstructor(scratchStateMachine) {\n\t\tthis.ssm = scratchStateMachine;\n\t\tthis.storage = new ScratchStorage();\n    this.projects = {};\n    this.untitledCount = 0;\n    // Project currently being edited\n    this.projectToPlay = null;\n    this.currentProject = null;\n    this.synth = window.speechSynthesis;\n    this.recognition = new webkitSpeechRecognition();\n    // Triggers should be listed from more specific to more general to\n    // ensure that the best fit trigger gets matched to the utterance.\n\t\tthis.triggers = ScratchRegex.getGeneralTriggers();\n\t}\n\n\tload() {\n\t\tif (!window.localStorage.scratchProjects) {\n\t\t\twindow.localStorage.scratchProjects = JSON.stringify({});\n\t\t}\n\t\tvar savedProjects = JSON.parse(window.localStorage.scratchProjects);\n\t\tfor (var name in savedProjects) {\n\t\t\tthis.projects[name] = new ScratchProject(this);\n\t\t\tthis.projects[name].name = name;\n\t\t\tthis.projects[name].instructions = savedProjects[name];\n\t\t}\n\t}\n\n\trenameProject(oldName, newName) {\n\t\tthis.projects[newName] = this.projects[oldName]\n\t\tthis.projects[newName].name = newName;\n\t\tdelete this.projects[oldName];\n\t\tthis.removeProject(oldName);\n\t\tthis.save();\n\t\tthis._updatePlayRegex();\n\t}\n\n\t/**\n\t * Delete project.\n\t */\n\tremoveProject(projName) {\n\t\tScratchStorage.removeProject(projName)\n\t}\n\n\t/**\n\t * Save project.\n\t */\n\tsave() {\n\t\t// Save project to local storage.\n\t\tScratchStorage.save()\n\t}\n\n\t/**\n\t * Speak aloud given text.\n\t * @param {!String} whatToSay - text to say aloud.\n\t */\n\tsay(whatToSay) {\n\t\tvar whatToSay = new SpeechSynthesisUtterance(whatToSay);\n\n\t\t// Stop speech recognition during speech synthesis.\n\t\tvar scratch = this;\n\t\twhatToSay.onstart = function(event) {\n\t\t\tscratch.recognition.stop();\n\t\t}\n\t\twhatToSay.onend = function(event) {\n\t\t\tscratch.recognition.start();\n\t\t}\n\n\t\t// Synthesis speech!\n\t\tthis.synth.speak(whatToSay);\n\t\tconsole.log('saying' + whatToSay.text);\n\t}\n\n\t/**\n\t * Execute current project.\n\t * @param {string} mode - 'FromStart' to execute the project from the first\n\t *    or 'WhereItLeftOff'.\n\t */\n\texecuteCurrentProject(scratch, mode) {\n\t\tif (!pm.currentProject) {\n\t\t\tconsole.log(scratch);\n\t\t\tthrow Error('pm.currentProject is ' + pm.currentProject);\n\t\t}\n\t\tif (mode == 'WhereItLeftOff') {\n\t\t\tvar startIndex = pm.currentProject.instructionPointer;\n\t\t} else if ('FromStart') {\n\t\t\t// Start at index 1 to skip the \"when green flag clicked instruction\"\n\t\t\tvar startIndex = 1;\n\t\t}\n\n\t\tvar scratchProgram = pm.currentProject.getScratchProgram();\n\t\tfor (var i = startIndex; i < scratchProgram.length; i++) {\n\t\t\tvar opcode = scratchProgram[i][0];\n\t\t\tvar args = scratchProgram[i][1];\n\t\t\tif (opcode == 'say:') {\n\t\t\t\t\tpm.say(scratchProgram[i][1]);\n\t\t\t} else if (Array.isArray(opcode)) {\n\t\t\t\tif (opcode[0] == 'doAsk')\n\t\t\t\t\tif (opcode[1] == '') {\n\t\t\t\t\t// Handle 'when i say event'\n\t\t\t\t\tvar whatToListenFor = args[1][2];\n\t\t\t\t\tvar whatToSay = args[2][0][1];\n\t\t\t\t\tpm.currentProject.tempTrigger = whatToListenFor;\n\t\t\t\t\tpm.currentProject.tempResponse= whatToSay;\n\t\t\t\t\tpm.currentProject.instructionPointer = i + 1;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handler utterance on the general navigation level.\n\t */\n\thandleUtterance(utterance) {\n\t\t// NOTE: 'this' refers to the ScratchStateMachine that calls this function\n\t\tvar lowercase = utterance.toLowerCase();\n\t\tvar utterance = Utils.removeFillerWords(lowercase).trim();\n\n\t\t// Attempt to match utterance to trigger.\n\t\tfor (var commandType in this.triggers) {\n\t\t\tvar args = Utils.match(utterance, this.triggers[commandType]);\n\t\t\tif (args && args.length > 0) {\n\t\t\t\tif (this.ssm.can(commandType)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// TODO: HAVING TROUBLE HERE W/ THE REFACTOR...\n\t\t\t\t\t\tthis.ssm[commandType](args, utterance);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t// Handle failure based on transition type.\n\t\t\t\t\t\tconsole.log(e)\n\t\t\t\t\t\tswitch (commandType) {\n\t\t\t\t\t\t\tcase 'editExistingProject':\n\t\t\t\t\t\t\t\t// If attempting to open a nonexistent project, stay in\n\t\t\t\t\t\t\t\t// current state.\n\t\t\t\t\t\t\t\tpm.say(\"There's no project called \" + nameOfDesiredProject);\n\t\t\t\t\t\t\t\tcommandType = 'stay';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'play':\n\t\t\t\t\t\t\t\tif (this.ssm.state == 'InsideProject') {\n\t\t\t\t\t\t\t\t\tif (this.ssm.currentProject.state == 'empty') {\n\t\t\t\t\t\t\t\t\t\t// User is trying to give a project the same name as a previous\n\t\t\t\t\t\t\t\t\t\t// project.\n\t\t\t\t\t\t\t\t\t\tpm.say('You already have a project called that.')\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// User is composing a Scratch program from other Scratch programs.\n\t\t\t\t\t\t\t\t\t\tvar result = this.ssm.currentProject.handleUtterance(utterance);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log('could not make transition: ' + commandType);\n\t\t\t\t\tconsole.log('current state: ' + this.ssm.state);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.ssm.state == 'PlayProject') {\n\t\t\t\tthis.ssm.currentProject.handleUtteranceDuringExecution(utterance);\n\t\t} else if (this.ssm.state == 'InsideProject') {\n\t\t // Handle utterances in the InsideProject context.\n\t\t\tif (this.currentProject) {\n\t\t\t\tvar result = this.currentProject.handleUtterance(utterance);\n\t\t\t\tif (result == 'exit') {\n\t\t\t\t\tthis.ssm.finishProject();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (utterance.toLowerCase().indexOf('scratch') != -1) {\n\t\t\t// TODO: integrate Scratch, Help!\n\t\t\tconsole.log('found Scratch in failed utterance');\n\t\t\tthis.say(\"I heard you say \" + utterance);\n\t\t\tthis.say(\"I don't know how to do that.\");\n\t\t}\n\t}\n\n\t// In order to properly detect playing projects, add project names to\n\t// match phrases for the play triggerType.\n\t_updatePlayRegex() {\n\t\tvar pattern = this.triggers['play'].toString();\n\t\tvar prefix = pattern.substring(1,pattern.length-1);\n\t\tvar regexString = prefix + '|(' + Object.keys(this.projects).map((projectName) => Utils.removeFillerWords(projectName).trim()).join(')|(') + ')';\n\t\tthis.triggers['play'] = new RegExp(regexString, \"i\");\n\t}\n\n\tgetCurrentProject() {\n\t\tif (this.currentProject) {\n\t\t\tthis.say('The current project is ' + this.currentProject.name);\n\t\t} else {\n\t\t\tthis.say('You are not currently on a project');\n\t\t}\n\t}\n\trenameCurrentProject(lifecycle, args) {\n\t\tif (this.currentProject) {\n\t\t\tvar newName = args[1];\n\t\t\tthis.renameProject(scratch, this.currentProject.name, newName);\n\t\t\tthis.say('The current project is now called ' + this.currentProject.name);\n\t\t} else {\n\t\t\tthis.say('You are not currently on a project');\n\t\t\t// TODO(quacht): support an interaction where instead of the above,\n\t\t\t// scratch also says and responds to\n\t\t\t// What project would you like to rename?\n\t\t}\n\t}\n\trenameSpecifiedProject(lifecycle, args) {\n\t\t\tvar oldName = args[1];\n\t\t\tvar newName = args[2];\n\n\t\t\t// play the project that matches!\n\t\t\tfor (var projectName in this.projects) {\n\t\t\t\tif (Utils.removeFillerWords(projectName) == oldName) {\n\t\t\t\t\tthis.renameProject(scratch, projectName, newName)\n\t\t\t\t\tthis.say('Renamed ' + projectName + ' to ' + newName)\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.say('The current project is ' + this.currentProject.name);\n\t\t\tthis.say('You are not currently on a project');\n\t\t\t// TODO(quacht): support an interaction where instead of the above,\n\t\t\t// scratch also says and responds to\n\t\t\t// What project would you like to rename?\n\t}\n\tdeleteProject(lifecycle, args, utterance) {\n\t\tvar pm = this;\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tvar projectToPlayName = args[1].trim();\n\n\t\t\t// play the project that matches!\n\t\t\tfor (var projectName in pm.projects) {\n\t\t\t\tif (Utils.removeFillerWords(projectName) == projectToPlayName) {\n\t\t\t\t\tpm.say(projectName + ' project deleted.')\n\t\t\t\t\tdelete pm.projects[projectName];\n\t\t\t\t\tScratchStorage.removeProject(projectName);\n\t\t\t\t\tresolve();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: Does args[1] actually contain the project name as it is said?\n\t\t\t// or will the filler words be removed.\n\t\t\tpm.say(\"You said \" + utterance);\n\t\t\tpm.say(\"I can't delete a project I don't have\");\n\t\t\tresolve();\n\t\t\tscratch.return();\n\t\t})\n\t}\n\tgetProjectNames() {\n\t\tvar pm = this;\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tvar whatToSay = Object.keys(pm.projects);\n\t\t\twhatToSay.splice(whatToSay.length-1, 0, 'and');\n\t\t\twhatToSay.join(',')\n\t\t\tpm.say(whatToSay);\n\t\t\tresolve();\n\t\t});\n\t}\n\tgetProjectCount() {\n\t\tvar pm = this;\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tvar count = Object.keys(pm.projects).length;\n\t\t\tpm.say('You have ' + count + ' projects');\n\t\t\tresolve();\n\t\t});\n\t}\n\tnewProject() {\n\t\tvar pm = this;\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tconsole.log(pm);\n\t\t\tpm.currentProject = new ScratchProject(pm);\n\t\t\tpm.untitledCount++;\n\t\t\tpm.projects['Untitled-' + pm.untitledCount] = pm.currentProject;\n\t\t\tpm.currentProject.startProjectCreation();\n\t\t\tresolve();\n\t\t});\n\t}\n\treturnToPreviousState() {\n\t\tvar pm = this;\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tpm.say('Returning to previous state: ' + pm.ssm.state);\n\t\t\tresolve();\n\t\t});\n\t}\n\t// Play existing project\n\tplay(lifecycle, args, utterance) {\n\t\tvar pm = this;\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tvar projectToPlayName = args[1].trim();\n\n\t\t\t// play the project that matches!\n\t\t\tfor (var projectName in pm.projects) {\n\t\t\t\tif (Utils.removeFillerWords(projectName) == projectToPlayName) {\n\t\t\t\t\tpm.currentProject = pm.projects[projectName];\n\t\t\t\t\tpm.say('playing project');\n\t\t\t\t\tpm.executeCurrentProject(scratch, 'FromStart');\n\t\t\t\t\t// TODO(quacht): saying I'm done playing the project doesnt work\n\t\t\t\t\t// here when doing event handling.\n\t\t\t\t\t// pm.say('done playing project');\n\t\t\t\t\tresolve();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: Does args[1] actually contain the project name as it is said?\n\t\t\t// or will the filler words be removed.\n\t\t\tpm.say(\"You said \" + utterance);\n\t\t\tpm.say(\"I don't have a project called \" + args[1]);\n\t\t\tresolve();\n\t\t\tscratch.return();\n\t\t})\n\t}\n\tfinishProject() {\n\t\tvar pm = this;\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tScratchStorage.save();\n\t\t\tpm._updatePlayRegex();\n\t\t\t// TODO: cue exiting project\n\t\t\t// Save project.\n\t\t\tresolve();\n\t\t});\n\t}\n\teditExistingProject(lifecycle, args) {\n\t\tvar pm = this;\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tconsole.log(args);\n\t\t\tvar projectName = args[1];\n\t\t\tvar stepCount = pm.projects[projectName].instructions.length;\n\t\t\tpm.say('Opening project ' + projectName + ' for editing');\n\t\t\tpm.say('There are ' + stepCount + ' steps');\n\t\t\tresolve();\n\t\t});\n\t}\n\teditProject() {\n\t\tvar pm = this;\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tpm.say('Opening project ' + pm.currentProject.name + ' for editing');\n\t\t\t// TODO: begin edit project flow.\n\t\t\tresolve();\n\t\t});\n\t}\n\tplayCurrentProject() {\n\t\tvar pm = this;\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tScratchStorage.save();\n\t\t\tpm.say('Playing current project ' + pm.currentProject.name);\n\t\t\tpm.executeCurrentProject(scratch, 'FromStart');\n\t\t\tpm.say('done playing project');\n\t\t\tresolve();\n\t\t});\n\t}\n}\n\nmodule.exports = ScratchProjectManager;\n\n//# sourceURL=webpack:///./src/scratch_project_manager.js?");

/***/ }),

/***/ "./src/scratch_state_machine.js":
/*!**************************************!*\
  !*** ./src/scratch_state_machine.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Defines a factory/constructor for the ScratchStateMachine\n *\n * @author quacht@mit.edu (Tina Quach)\n */\nconst StateMachine = __webpack_require__(/*! javascript-state-machine */ \"./node_modules/javascript-state-machine/lib/state-machine.js\");\nconst StateMachineHistory = __webpack_require__(/*! javascript-state-machine/lib/history */ \"./node_modules/javascript-state-machine/lib/history.js\")\nconst ScratchStorage = __webpack_require__(/*! ./storage.js */ \"./src/storage.js\");\nconst ScratchProjectManager = __webpack_require__(/*! ./scratch_project_manager.js */ \"./src/scratch_project_manager.js\");\nconst Utils = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n\nvar ScratchStateMachine = new StateMachine.factory({\n  init: 'Home',\n  transitions: [\n    { name: 'renameCurrentProject', from: '*', to: function() { return this.state} },\n    { name: 'renameProject', from: '*', to: function() { return this.state} },\n    { name: 'deleteProject', from: '*', to: function() { return this.state} },\n    { name: 'editExistingProject', from: 'Home',  to: 'InsideProject' },\n    { name: 'newProject', from: 'Home',  to: 'InsideProject' },\n    // Return should take you back to the last state\n    { name: 'return',   from: '*', to: function() {\n        return this.history[this.history.length - 2];\n      }\n    }, {\n      name: 'finishProject', from: 'InsideProject', to: 'Home'},\n    { name: 'play', from: 'Home', to: 'PlayProject'},\n    { name: 'play', from: 'PlayProject', to: 'PlayProject'},\n    { name: 'newProject', from: 'PlayProject',  to: 'InsideProject' },\n    { name: 'playCurrentProject', from: 'InsideProject', to: 'PlayProject'},\n    { name: 'editProject', from: 'PlayProject', to: 'InsideProject' },\n    // Support this.goto(STATE_NAME);\n    { name: 'goto', from: '*', to: function(s) { return s } },\n    { name: 'stay', from: '*', to: function() { return this.state} },\n    { name: 'getCurrentProject', from: '*', to: function() { return this.state} },\n    { name: 'getProjectNames', from: '*', to: function() { return this.state} },\n    { name: 'getProjectCount', from: '*', to: function() { return this.state} },\n\n  ],\n  data: function() {\n    var ssm = this;\n    return {\n      pm: new ScratchProjectManager(ssm)\n    };\n  },\n  plugins: [\n    new StateMachineHistory()     //  <-- plugin enabled here\n  ],\n  methods: {\n    // Initialize the state machine.\n    onHome: function() {\n      if (!window.localStorage.scratchProjects) {\n        window.localStorage.scratchProjects = JSON.stringify({});\n      } else {\n        this.pm.load();\n      }\n      this.setMethods();\n      this.pm._updatePlayRegex();\n    },\n    setSpeechRecognition: function() {\n      this.pm.updateGrammarWithProjects.bind(this);\n      this.pm.recognition.grammars.addFromString(ScratchGrammar.commands);\n      this.pm.recognition.grammars.addFromString(ScratchGrammar.numbers);\n      this.pm.recognition.grammars.addFromString(ScratchGrammar.sounds);\n    },\n    setMethods: function() {\n      methodMap = {\n        handleUtterance: (utterance) => {this.pm.handleUtterance(utterance)},\n        onGetCurrentProject: () => {this.pm.getCurrentProject()},\n        onRenameCurrentProject: (lifecycle, args) => {this.pm.renameCurrentProject(lifecycle, args)},\n        onRenameProject: (lifecycle, args) => {this.pm.renameSpecifiedProject(lifecycle, args)},\n        onDeleteProject: (lifecycle, args, utterance) => {this.pm.deleteProject(lifecycle, args, utterance)},\n        onGetProjectNames: () => {this.pm.getProjectNames()},\n        onGetProjectCount: () => {this.pm.getProjectCount()},\n        onNewProject: () => {this.pm.newProject()},\n        onReturn: (lifecycle, args) => {this.pm.returnToPreviousState(lifecycle, args)},\n        // Play existing project\n        onPlay: (lifecycle, args, utterance) => {this.pm.play(lifecycle, args, utterance)},\n        onFinishProject: () => {this.pm.finishProject()},\n        onEditExistingProject: (lifecycle, args) => {this.pm.editExistingProject(lifecycle, args)},\n        onEditProject: () => {this.pm.editProject()},\n        onPlayCurrentProject: () => {this.pm.playCurrentProject()},\n      }\n      for (var method in methodMap) {\n        this[method] = methodMap[method];\n      }\n    }\n  }\n});\n\nmodule.exports = ScratchStateMachine;\n\n\n//# sourceURL=webpack:///./src/scratch_state_machine.js?");

/***/ }),

/***/ "./src/storage.js":
/*!************************!*\
  !*** ./src/storage.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview Manage storage of projects in browser.\n */\nconst ScratchProject = __webpack_require__(/*! ./scratch_project.js */ \"./src/scratch_project.js\");\n\nclass ScratchStorage {\n\n\tstatic removeProject(projectName) {\n\t\tif (window.localStorage.scratchProjects) {\n\t\t\tvar savedProjects = JSON.parse(window.localStorage.scratchProjects);\n\t\t\tdelete savedProjects[projectName];\n\t\t\twindow.localStorage.scratchProjects = JSON.stringify(savedProjects);\n\t\t}\n\t}\n\n\tstatic save(scratch) {\n\t\tif (!window.localStorage.scratchProjects) {\n\t\t\twindow.localStorage.scratchProjects = JSON.stringify({});\n\t\t}\n\t\tfor (var projectName in this.projects) {\n\t\t\tvar savedProjects = JSON.parse(window.localStorage.scratchProjects);\n\t\t\tsavedProjects[projectName] = this.projects[projectName].instructions;\n\t\t\twindow.localStorage.scratchProjects = JSON.stringify(savedProjects);\n\t\t}\n\t}\n}\n\nmodule.exports = ScratchStorage;\n\n//# sourceURL=webpack:///./src/storage.js?");

/***/ }),

/***/ "./src/triggers.js":
/*!*************************!*\
  !*** ./src/triggers.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * This file specifies the forms of commands supported by the Scratch Voice\n * User Interface.\n */\n\n/**\n * ScratchRegex namespace.\n */\nScratchRegex = {};\n\nScratchRegex.getGeneralTriggers = function() {\n\treturn {\n\t  'newProject': /new project|create a? new project|create a? project|make a? new project|make a? project/,\n\t  'deleteProject': /delete (.*) project/,\n\t  'renameCurrentProject': /rename current project to (.*)/,\n\t  'renameProject': /change name of (.*) project to (.*)/,\n\t  'editExistingProject': /see inside (.*)|what's inside (.*)/,\n\t  'editProject': /see inside|what's inside/,\n\t  'finishProject': /i'm done|i'm finished/,\n\t  'play': /scratch (.*)|scratch play (.*)|play (.*)/,\n\t  'playCurrentProject': /play (?:the)? ?project|start (?:the)? ?project|play c(?:the)? ?urrent project|test (?:the)? ?project/,\n\t  'return': /stop|i'm done|go back|quit|exit/,\n\t  'getCurrentProject': /get (?:the)? ?current project|what project am i on|what’s my current project|what is my current project/,\n\t  'getProjectNames': /what projects do i have|what have i made so far|what are my projects called/,\n\t  'getProjectCount': /how many projects do i have|how many projects have i made/\n\t}\n}\n\nScratchRegex.getEditProjectTriggers = function() {\n\treturn {\n\t  'newProject': /new project|create a? new project|create a? project|make a? new project|make a? project/,\n\t  'deleteProject': /delete (.*) project/,\n\t  'renameCurrentProject': /rename current project to (.*)/,\n\t  'renameProject': /change name of (.*) project to (.*)/,\n\t  'editExistingProject': /see inside (.*)|what's inside (.*)/,\n\t  'editProject': /see inside|what's inside/,\n\t  'finishProject': /i'm done|i'm finished/,\n\t  'play': /scratch (.*)|scratch play (.*)|play (.*)/,\n\t  'playCurrentProject': /play (?:the)? ?project|start (?:the)? ?project|play c(?:the)? ?urrent project|test (?:the)? ?project/,\n\t  'return': /stop|i'm done|go back|quit|exit/,\n\t  'getCurrentProject': /get (?:the)? ?current project|what project am i on|what’s my current project|what is my current project/,\n\t  'getProjectNames': /what projects do i have|what have i made so far|what are my projects called/,\n\t  'getProjectCount': /how many projects do i have|how many projects have i made/\n\t}\n}\n\nmodule.exports = ScratchRegex;\n\n\n\n//# sourceURL=webpack:///./src/triggers.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Utility functions used across files.\n */\n\n/**\n * Namespace\n */\n Utils = {}\n\n/**\n* Get all defined matches of string to given regular expression.\n*/\nUtils.match = (utterance, pattern) => {\n\tvar matches = utterance.match(pattern, \"i\");\n\treturn matches ? matches.filter(word => word != undefined && word != \"\") : null\n}\n\nUtils.text2num = (numberWord) => {\n\tvar parseResult = parseInt(numberWord);\n\tif (!isNaN(parseResult)) {\n\t\treturn numberWord;\n\t}\n\n\tvar a, n, g;\n\ta = numberWord.toString().split(/[\\s-]+/);\n\tn = 0;\n\tg = 0;\n\n\tvar Small = {\n\t\t'zero': 0,\n\t\t'one': 1,\n\t\t'two': 2,\n\t\t'three': 3,\n\t\t'four': 4,\n\t\t'five': 5,\n\t\t'six': 6,\n\t\t'seven': 7,\n\t\t'eight': 8,\n\t\t'nine': 9,\n\t\t'ten': 10,\n\t\t'eleven': 11,\n\t\t'twelve': 12,\n\t\t'thirteen': 13,\n\t\t'fourteen': 14,\n\t\t'fifteen': 15,\n\t\t'sixteen': 16,\n\t\t'seventeen': 17,\n\t\t'eighteen': 18,\n\t\t'nineteen': 19,\n\t\t'twenty': 20,\n\t\t'thirty': 30,\n\t\t'forty': 40,\n\t\t'fifty': 50,\n\t\t'sixty': 60,\n\t\t'seventy': 70,\n\t\t'eighty': 80,\n\t\t'ninety': 90\n\t};\n\n\tvar Magnitude = {\n\t\t'thousand':     1000,\n\t\t'million':      1000000,\n\t\t'billion':      1000000000,\n\t\t'trillion':     1000000000000,\n\t\t'quadrillion':  1000000000000000,\n\t\t'quintillion':  1000000000000000000,\n\t\t'sextillion':   1000000000000000000000,\n\t\t'septillion':   1000000000000000000000000,\n\t\t'octillion':    1000000000000000000000000000,\n\t\t'nonillion':    1000000000000000000000000000000,\n\t\t'decillion':    1000000000000000000000000000000000,\n\t};\n\n\tfunction feach(w) {\n\t\tvar x = Small[w];\n\t\tif (x != null) {\n\t\t\t\tg = g + x;\n\t\t}\n\t\telse if (w == \"hundred\") {\n\t\t\t\tg = g * 100;\n\t\t}\n\t\telse {\n\t\t\t\tx = Magnitude[w];\n\t\t\t\tif (x != null) {\n\t\t\t\t\t\tn = n + g * x\n\t\t\t\t\t\tg = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t}\n\t}\n\n\ta.forEach(feach);\n\treturn n + g;\n}\n\nUtils.removeFillerWords = function(utterance) {\n\tvar filler_words = [\"um\", \"uh\", \"er\", \"ah\", \"like\"];\n\n\tvar utterance = utterance.toLowerCase();\n\tvar stripped = utterance.replace(/\\b[-.,()&$#!\\[\\]{}\"']+\\B|\\B[-.,()&$#!\\[\\]{}\"']+\\b/g, \"\");\n\tvar tokens = stripped.split(' ');\n\tvar result = tokens.filter(token => filler_words.indexOf(token) == -1);\n\treturn result.join(' ');\n};\n\nmodule.exports = Utils;\n\n//# sourceURL=webpack:///./src/utils.js?");

/***/ })

/******/ });